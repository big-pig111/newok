<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NEWOX ä»£å¸ç›‘æ§ - XLayeré“¾</title>
  <script>
    (function loadEthersWithFallback() {
      var urls = [
        'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js',
        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
      ];
      function tryLoad(index) {
        if (index >= urls.length) {
          console.error('Failed to load ethers.js from all CDNs');
          return;
        }
        var s = document.createElement('script');
        s.src = urls[index];
        s.async = false;
        s.onload = function () { console.log('ethers.js loaded from', urls[index]); };
        s.onerror = function () { console.warn('CDN failed:', urls[index]); tryLoad(index + 1); };
        document.head.appendChild(s);
      }
      tryLoad(0);
    })();
    // æ‰¹é‡å›å¡«å†å²ä»£å¸ç¼ºå¤±çš„ name/symbolï¼Œå¹¶åŒæ­¥åˆ° Firebase
    async function backfillMissingMeta() {
      try {
        const targets = (deployedTokens || []).filter(t => t && t.address && (!t.name || !t.symbol));
        if (targets.length === 0) {
          showNotification('æ²¡æœ‰éœ€è¦ä¿®å¤çš„ä»£å¸åç§°', 'info');
          return;
        }
        showNotification(`å¼€å§‹ä¿®å¤ ${targets.length} ä¸ªä»£å¸åç§°...`, 'info');
        let fixed = 0;
        for (const t of targets) {
          try {
            if (t.source === 'okay-monitoring') {
              const info = await getTokenInfoFromContract(t.address);
              if (info) {
                if (info.name && !t.name) t.name = info.name;
                if (info.symbol && !t.symbol) t.symbol = info.symbol;
                if (info.image && !t.image) t.image = info.image;
                fixed++;
              }
            } else {
              await ensureDYORMeta(t.address);
              if (t.name || t.symbol) fixed++;
            }
          } catch (e) {
            console.warn('å•ä¸ªä»£å¸ä¿®å¤å¤±è´¥:', t?.address, e);
          }
          // è½»å¾®å»¶æ—¶ï¼Œé¿å…è¯·æ±‚è¿‡å¿«
          await new Promise(r => setTimeout(r, 80));
        }
        updateTokenDisplay();
        try {
          await saveToFirebase({
            tokens: deployedTokens,
            tokenData: tokenData,
            lastUpdated: Date.now()
          }, 'pumpu_tokens');
        } catch (e) { console.warn('ä¿®å¤ååŒæ­¥ Firebase å¤±è´¥:', e); }
        showNotification(`åç§°ä¿®å¤å®Œæˆï¼š${fixed}/${targets.length}`, 'success');
      } catch (err) {
        console.error('æ‰¹é‡å›å¡«åç§°å¤±è´¥:', err);
        showNotification('ä¿®å¤å¤±è´¥ï¼š' + (err?.message || err), 'error');
      }
    }
  </script>
     <!-- ç§»é™¤å¯¹ä¸å­˜åœ¨çš„config.jsçš„å¼•ç”¨ -->
  <style>
    /* é‡ç½® & åŸºç¡€æ ·å¼ */
    * {
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      font-family: "Helvetica Neue", Arial, sans-serif;
    }
    body {
      background-color: #121212; 
      color: #fff; 
      line-height: 1.4; 
      overflow-y: auto; 
    }
    a {
      color: #fff; 
      text-decoration: none;
    }
    
    /* é¡¶éƒ¨å¯¼èˆª */
    .top-nav {
      display: flex; 
      align-items: center; 
      justify-content: space-between;
      background-color: #1e1e1e; 
      padding: 10px 20px;
      border-bottom: 1px solid #2c2c2c;
    }
    .top-nav .logo {
      font-size: 20px; 
      font-weight: bold; 
      color: #00d8ff;
    }
         .top-nav .menu {
       display: flex; 
       gap: 20px;
     }
     .top-nav .menu a {
       padding: 8px 12px;
       border-radius: 4px;
       transition: all 0.3s ease;
       position: relative;
     }
     .top-nav .menu a:hover {
       background-color: rgba(0, 216, 255, 0.1);
       transform: translateY(-1px);
     }
     .top-nav .menu a.active {
       color: #00d8ff !important;
       font-weight: bold !important;
       border-bottom: 2px solid #00d8ff !important;
     }
    .top-nav .search {
      display: flex; 
      align-items: center; 
      background-color: #2c2c2c; 
      padding: 5px 10px; 
      border-radius: 4px;
    }
    .top-nav .search input {
      background: transparent; 
      border: none; 
      color: #fff; 
      outline: none; 
      margin-left: 5px;
    }
    
    /* é’±åŒ…è¿æ¥æŒ‰é’® */
    .connect-wallet {
      background-color: #00d8ff;
      color: #000;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      border: none;
      margin-left: 20px;
    }
    .connect-wallet:hover {
      background-color: #00b8d9;
    }
    .wallet-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .wallet-address {
      font-size: 12px;
      color: #00d8ff;
      background-color: #2c2c2c;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .status-live {
      background-color: #00ff00;
      animation: pulse 2s infinite;
    }
    .status-pending {
      background-color: #ffaa00;
    }
    .status-closed {
      background-color: #ff4444;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* å®¹å™¨ & åˆ—è¡¨å¸ƒå±€ */
    .container {
      display: flex; 
      padding: 20px; 
      gap: 20px;
    }
    .column {
      flex: 1; 
      background-color: #1e1e1e; 
      border-radius: 8px; 
      padding: 15px; 
      border: 1px solid #2c2c2c;
    }
    .column h2 {
      font-size: 16px; 
      margin-bottom: 15px; 
      color: #fff; 
      opacity: 0.9;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .refresh-btn {
      background-color: #333;
      color: #fff;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .refresh-btn:hover {
      background-color: #444;
    }
    
    .card {
      display: flex; 
      align-items: center; 
      background-color: #2c2c2c; 
      border-radius: 6px; 
      padding: 10px; 
      margin-bottom: 10px; 
      gap: 10px;
      border-left: 4px solid #00d8ff;
      transition: all 0.3s ease;
    }
         .card:hover {
       transform: translateY(-2px);
       box-shadow: 0 4px 12px rgba(0, 216, 255, 0.2);
     }
     
     /* å‘å°„å°æ ‡è¯†æ ·å¼ */
     .launchpad-badge {
       display: inline-block;
       padding: 2px 8px;
       border-radius: 12px;
       font-size: 10px;
       font-weight: bold;
       margin-left: 8px;
       text-transform: uppercase;
       letter-spacing: 0.5px;
     }
     
     .okay-launchpad .launchpad-badge {
       background-color: #00ff00;
       color: #000;
     }
     
     .dyor-launchpad .launchpad-badge {
       background-color: #00d8ff;
       color: #000;
     }
     
     /* ä¸åŒå‘å°„å°ä»£å¸çš„è¾¹æ¡†é¢œè‰² */
     .card.okay-launchpad {
       border-left-color: #00ff00;
     }
     
     .card.dyor-launchpad {
       border-left-color: #00d8ff;
     }
     
     .card.okay-launchpad:hover {
       box-shadow: 0 4px 12px rgba(0, 255, 0, 0.3);
     }
     
     .card.dyor-launchpad:hover {
       box-shadow: 0 4px 12px rgba(0, 216, 255, 0.3);
     }
     
     /* å‘å°„å°ç»Ÿè®¡ä¿¡æ¯æ ·å¼ */
     .launchpad-stats {
       background: #2c2c2c;
       padding: 15px;
       border-radius: 8px;
       margin-bottom: 15px;
       border-left: 4px solid #00d8ff;
     }
     
     .launchpad-stats.okay {
       border-left-color: #00ff00;
     }
     

     
     .launchpad-stats h3 {
       color: #00d8ff;
       margin-bottom: 10px;
       font-size: 14px;
     }
     
     .launchpad-stats.okay h3 {
       color: #00ff00;
     }
     

     
     .launchpad-stats .stats-grid {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 10px;
     }
     
     .launchpad-stats .stat-item {
       text-align: center;
       padding: 8px;
       background: #1e1e1e;
       border-radius: 4px;
     }
     
     .launchpad-stats .stat-value {
       font-size: 18px;
       font-weight: bold;
       color: #00d8ff;
     }
     
     .launchpad-stats.okay .stat-value {
       color: #00ff00;
     }
     

     
     .launchpad-stats .stat-label {
       font-size: 11px;
       color: #aaa;
       margin-top: 2px;
     }
     
     /* ä»·æ ¼å˜åŒ–æŒ‡ç¤ºå™¨æ ·å¼ */
     .price-change {
       display: inline-block;
       padding: 2px 6px;
       border-radius: 3px;
       font-size: 11px;
       font-weight: bold;
       margin-left: 5px;
     }
     
     .price-change.positive {
       background: #00ff00;
       color: #000;
     }
     
     .price-change.negative {
       background: #ff4444;
       color: #fff;
     }
    .card .avatar {
      width: 40px; 
      height: 40px; 
      border-radius: 50%; 
      background-color: #333; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: bold; 
      color: #fff;
      flex-shrink: 0;
      overflow: hidden;
    }
    .card .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .card .info {
      flex: 1;
    }
    .card .info .title {
      font-size: 14px; 
      font-weight: bold; 
      margin-bottom: 4px; 
      color: #fff;
      display: flex;
      align-items: center;
    }
    .card .info .desc {
      font-size: 12px; 
      color: #aaa; 
      line-height: 1.4;
    }
    .card .stats {
      font-size: 12px; 
      color: #ccc; 
      text-align: right;
    }
    .buy-btn {
      background-color: #00d8ff; 
      color: #000; 
      font-size: 12px; 
      padding: 4px 8px; 
      border-radius: 4px; 
      cursor: pointer; 
      margin-left: 10px; 
      display: inline-block;
      transition: background-color 0.3s ease;
    }
    .buy-btn:hover {
      background-color: #00b8d9;
    }
    
    /* åŠ è½½çŠ¶æ€ */
    .loading {
      text-align: center;
      padding: 20px;
      color: #aaa;
    }
    .spinner {
      border: 2px solid #333;
      border-top: 2px solid #00d8ff;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
         /* ä»£å¸è¯¦æƒ…æ¨¡æ€æ¡† */
     .modal {
       display: none;
       position: fixed;
       z-index: 1000;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.8);
     }
     .modal-content {
       background-color: #1e1e1e;
       margin: 3vh auto;
       padding: 30px;
       border-radius: 12px;
       width: 95%;
       max-width: 900px;
       max-height: 94vh;
       border: 1px solid #2c2c2c;
       box-sizing: border-box;
     }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close:hover {
      color: #fff;
    }
         .token-details {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 25px;
     }
     .detail-item {
       background-color: #2c2c2c;
       padding: 20px;
       border-radius: 8px;
     }
    .detail-item h4 {
      color: #00d8ff;
      margin-bottom: 10px;
    }
    
         /* å“åº”å¼è®¾è®¡ */
     @media (max-width: 768px) {
       .container {
         flex-direction: column;
       }
       .top-nav .menu {
         display: none;
       }
       .token-details {
         grid-template-columns: 1fr;
       }
       
       /* ç§»åŠ¨ç«¯æ¨¡æ€æ¡†ä¼˜åŒ– */
       .modal-content {
         width: 98%;
         margin: 1vh auto;
         padding: 20px;
         max-height: 98vh;
       }
       
       .token-details {
         gap: 15px;
       }
       
       .detail-item {
         padding: 12px;
       }
     }
  </style>
</head>
<body>

  <!-- é¡¶éƒ¨å¯¼èˆª -->
      <div class="top-nav">
      <div class="logo">NEWOX ä»£å¸ç›‘æ§</div>
             <div class="menu">
         <a href="#" onclick="showHome()" style="color: #00d8ff; font-weight: bold;">ğŸ  é¦–é¡µ</a>
         <a href="#" onclick="showColumn('new')">æ–°åˆ›å»º</a>
         <a href="#" onclick="showColumn('pending')">å³å°†æ‰“æ»¡</a>
         <a href="#" onclick="showColumn('opened')">å·²å¼€ç›˜</a>
                   <a href="#" onclick="showColumn('monitoring')">ğŸš€ DYORå‘å°„å°</a>
          <a href="#" onclick="showColumn('okay-monitoring')">ğŸš€ OKAYå‘å°„å°</a>
         <a href="#" onclick="showColumn('history')">ğŸ“š å†å²è®°å½•</a>
+        <a href="https://x.com/xnew_okx?s=21" target="_blank" rel="noopener noreferrer">ğŸ¦ å®˜æ–¹æ¨ç‰¹</a>
       </div>
      <div id="sync-status" style="color: #00d8ff; font-size: 12px; margin-right: 10px;">
        <span id="sync-indicator">ğŸ”„ åŒæ­¥ä¸­...</span>
      </div>
    <div class="search">
      <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
        <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.098ZM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"/>
      </svg>
      <input type="text" placeholder="æœç´¢ä»£å¸/é’±åŒ…" onkeyup="searchTokens(this.value)" />
      <input id="trackAddressInput" type="text" placeholder="è¾“å…¥åˆçº¦åœ°å€æ·»åŠ ç›‘æ§" style="margin-left:10px; min-width:240px;" onkeydown="if(event.key==='Enter'){trackAddressFromTopBar()}" />
      <button class="refresh-btn" style="margin-left:6px;" onclick="trackAddressFromTopBar()">æ·»åŠ </button>
      <!-- ä¿®å¤æŒ‰é’®ï¼šå·²éšè—ï¼ˆä»£å¸åç§°å·²æ­£å¸¸æ˜¾ç¤ºï¼‰ -->
      <button id="fix-meta-btn" class="refresh-btn" style="margin-left:6px; display:none;" onclick="forceRefreshTokenNames()">ä¿®å¤åç§°</button>
    </div>
    <div id="wallet-section">
      <button class="connect-wallet" onclick="connectWallet()">è¿æ¥é’±åŒ…</button>
    </div>
  </div>

     <!-- é¢åŒ…å±‘å¯¼èˆª -->
   <div id="breadcrumb" style="padding: 10px 20px; color: #00d8ff; font-size: 14px; border-bottom: 1px solid #2c2c2c;">
     <span id="current-page">ğŸ  é¦–é¡µ - ç›‘æ§æ¦‚è§ˆ</span>
   </div>

   <!-- ä¸»å®¹å™¨ï¼šåˆ†ä¸‰åˆ— -->
   <div class="container">
    <!-- ç¬¬ä¸€åˆ—ï¼šæ–°åˆ›å»º -->
    <div class="column" id="new-tokens">
      <h2>
        æ–°åˆ›å»º
        <button class="refresh-btn" onclick="refreshNewTokens()">åˆ·æ–°</button>
      </h2>
      <div class="loading">
        <div class="spinner"></div>
        æ­£åœ¨ç›‘å¬æ–°ä»£å¸...
      </div>
    </div>

    <!-- ç¬¬äºŒåˆ—ï¼šå³å°†æ‰“æ»¡ -->
    <div class="column" id="pending-tokens">
      <h2>
        å³å°†æ‰“æ»¡
        <button class="refresh-btn" onclick="refreshPendingTokens()">åˆ·æ–°</button>
      </h2>
      <div class="loading">
        <div class="spinner"></div>
        åŠ è½½ä¸­...
      </div>
    </div>

    <!-- ç¬¬ä¸‰åˆ—ï¼šå·²å¼€ç›˜ -->
    <div class="column" id="opened-tokens">
      <h2>
        å·²å¼€ç›˜
        <button class="refresh-btn" onclick="refreshOpenedTokens()">åˆ·æ–°</button>
      </h2>
      <div class="loading">
        <div class="spinner"></div>
        åŠ è½½ä¸­...
      </div>
    </div>
               <!-- ç¬¬å››åˆ—ï¼šDYORå‘å°„å°ç›‘æ§ -->
      <div class="column" id="monitoring-tokens" style="display:none;">
        <h2>
          ğŸš€ DYORå‘å°„å°ç›‘æ§
          <button class="refresh-btn" onclick="refreshMonitoringTokens()">åˆ·æ–°</button>
          <button class="refresh-btn" onclick="updateDYORTokensPriceAndLiquidity()" style="margin-left: 5px; background: #00d8ff;">æ›´æ–°ä»·æ ¼</button>
        </h2>
        <div class="price-monitoring-status" style="background: #1e1e1e; padding: 10px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #00d8ff;">
          <div style="display: flex; align-items: center; justify-content: space-between;">
            <span style="color: #00d8ff; font-weight: bold;">ğŸ’° ä»·æ ¼ç›‘æ§çŠ¶æ€</span>
            <span id="dyor-price-status" style="color: #00ff00;">ğŸ”„ ç›‘æ§ä¸­...</span>
          </div>
          <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
            è‡ªåŠ¨æ›´æ–°é—´éš”: 30ç§’ | ä»·æ ¼å˜åŒ–é˜ˆå€¼: ${(userPreferences.priceChangeThreshold * 100).toFixed(1)}%
          </div>
        </div>
        
        <div class="price-summary" style="background: #1e1e1e; padding: 10px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #00d8ff;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <span style="color: #00d8ff; font-weight: bold;">ğŸ“Š ä»·æ ¼æ¦‚è§ˆ</span>
            <span id="dyor-price-summary" style="color: #aaa;">åŠ è½½ä¸­...</span>
          </div>
          <div id="dyor-price-details" style="font-size: 12px; color: #aaa;">
            <!-- åŠ¨æ€å¡«å……ä»·æ ¼è¯¦æƒ… -->
          </div>
        </div>
        <div class="loading">
          <div class="spinner"></div>
          æš‚æ— DYORå‘å°„å°ç›‘æ§ä»£å¸
        </div>
      </div>
      
      <!-- ç¬¬äº”åˆ—ï¼šOKAYå‘å°„å°ç›‘æ§ -->
      <div class="column" id="okay-monitoring-tokens" style="display:none;">
        <h2>
          ğŸš€ OKAYå‘å°„å°ç›‘æ§
          <button class="refresh-btn" onclick="refreshOkayMonitoringTokens()">åˆ·æ–°</button>
          <button class="refresh-btn" onclick="addOkayToken()" style="margin-left: 5px; background: #00ff00;">æ·»åŠ ä»£å¸</button>
        <button class="refresh-btn" onclick="testSpecificToken()" style="margin-left: 5px; background: #ff8800;">æµ‹è¯•æŒ‡å®šä»£å¸</button>
          <button class="refresh-btn" onclick="clearAllOkayTokens()" style="margin-left: 5px; background: #ff4444;">æ¸…ç©ºæ‰€æœ‰</button>
        </h2>
        <div class="loading">
          <div class="spinner"></div>
          æš‚æ— OKAYå‘å°„å°ç›‘æ§ä»£å¸
        </div>
      </div>
     
     <!-- ç¬¬å…­åˆ—ï¼šå†å²è®°å½• -->
     <div class="column" id="history-tokens" style="display:none;">
       <h2>
         å†å²è®°å½•
         <button class="refresh-btn" onclick="refreshHistoryTokens()">åˆ·æ–°</button>
         <button class="refresh-btn" onclick="clearHistory()" style="margin-left: 5px; background: #ff4444;">æ¸…ç©º</button>
       </h2>
       <div class="history-filters">
         <select id="historyTypeFilter" onchange="filterHistory()">
           <option value="all">å…¨éƒ¨è®°å½•</option>
           <option value="created">ä»£å¸åˆ›å»º</option>
           <option value="status_change">çŠ¶æ€å˜åŒ–</option>
           <option value="purchase">è´­ä¹°è®°å½•</option>
           <option value="monitor">ç›‘æ§æ“ä½œ</option>
         </select>
         <input type="date" id="historyDateFilter" onchange="filterHistory()" style="margin-left: 10px;">
       </div>
       <div class="loading">
         <div class="spinner"></div>
         åŠ è½½å†å²è®°å½•ä¸­...
       </div>
     </div>
   </div>

     <!-- ä»£å¸è¯¦æƒ…æ¨¡æ€æ¡† -->
   <div id="tokenModal" class="modal">
     <div class="modal-content">
       <div class="modal-header">
         <h3 id="modalTitle">ä»£å¸è¯¦æƒ…</h3>
         <span class="close" onclick="closeModal()">&times;</span>
       </div>
       <div class="token-details" id="modalDetails">
         <!-- åŠ¨æ€å¡«å……å†…å®¹ -->
       </div>
     </div>
   </div>

               <!-- è´­ä¹°ç•Œé¢æ¨¡æ€æ¡† -->
     <div id="buyModal" class="modal">
       <div class="modal-content" style="max-width: 700px; max-height: 85vh;">
         <div class="modal-header">
           <h3 id="buyModalTitle">è´­ä¹°ä»£å¸</h3>
           <span class="close" onclick="closeBuyModal()">&times;</span>
         </div>
         <div id="buyModalContent">
           <!-- åŠ¨æ€å¡«å……è´­ä¹°ç•Œé¢ -->
         </div>
       </div>
     </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
  
  <script>
    // Firebase é…ç½®
    const firebaseConfig = {
      apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
      authDomain: "chat-294cc.firebaseapp.com",
      databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
      projectId: "chat-294cc",
      storageBucket: "chat-294cc.firebasestorage.app",
      messagingSenderId: "913615304269",
      appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
      measurementId: "G-SJR9NDW86B"
    };

    // åˆå§‹åŒ– Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

         // é…ç½®
     const CONFIG = {
       XLAYER_RPC: 'https://xlayerrpc.okx.com', // XLayerä¸»ç½‘RPCï¼ˆOKXå®˜æ–¹èŠ‚ç‚¹ï¼‰
       XLAYER_RPC_BACKUP: 'https://rpc.xlayer.com', // å¤‡ç”¨RPCç«¯ç‚¹
       XLAYER_CHAIN_ID_HEX: '0xC4', // 196 (XLayer ä¸»ç½‘)
       PUMPU_FACTORY: '0xC4cEBDf3D4bBF14812DcCB1ccB20AB26EA547f44',
       WOKB: '0xe538905cf8410324e03a5a23c1c177a474d59b2b',
               PUMPU_ROUTER: '0x95E6739000000000000000000000000000000000', // Pumpu Router åœ°å€ï¼ˆéœ€è¦ç¡®è®¤æ­£ç¡®åœ°å€ï¼‰
       PUMPU_FACTORY_ABI: [
         "event Deployed(address indexed addr, uint256 amount)",
         // æ³¨æ„ï¼šå¦‚æœFactoryæ²¡æœ‰æ­¤å‡½æ•°ï¼Œè¯·ä¸è¦è°ƒç”¨
         "function getDeployedTokens() external view returns (address[] memory)"
       ],
       PUMP_TOKEN_ABI: [
         "function description() external view returns (string memory)",
         "function image() external view returns (string memory)",
         "function website() external view returns (string memory)",
         "function telegram() external view returns (string memory)",
         "function twitter() external view returns (string memory)"
       ],
       ROUTER_ABI: [
         "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)",
         "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)",
         "function WETH() external pure returns (address)",
         "function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
         "function token0() external view returns (address)",
         "function token1() external view returns (address)"
       ]
     };

    // å¼€ç›˜æ£€æµ‹ä¸ä»·æ ¼ç›‘æ§é…ç½®
    const OPENING_DETECTION_CONFIG = {
      STATUS_CHECK_INTERVAL: 30000, // 30s æ£€æŸ¥çŠ¶æ€
      PRICE_MONITORING: { UPDATE_INTERVAL: 10000 }, // 10s æ›´æ–°ä»·æ ¼
      OPENING_CONDITIONS: {
        MIN_LIQUIDITY_OKB: 50, // è‡³å°‘ 50 OKB æµåŠ¨æ€§
        MIN_TRADE_VOLUME: 0, // æ— æ³•æ— åç«¯ç²¾ç¡®ç»Ÿè®¡ï¼Œå…ˆç½® 0
        MIN_HOLDER_COUNT: 0, // æ—  indexerï¼Œå…ˆç½® 0
        MAX_TIME_AFTER_DEPLOY: 0 // ä¸ä»¥æ—¶é—´ä½œä¸ºé˜»æ–­æ¡ä»¶
      }
    };

    // å…¬å…± ABIï¼ˆPair/Pumpu æ‰©å±•ï¼‰
    const PAIR_ABI = [
      'function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)',
      'function token0() view returns (address)',
      'function token1() view returns (address)'
    ];
    const PUMP_TOKEN_EXT_ABI = [
      'function virtualEth() view returns (uint256)',
      'function virtualToken() view returns (uint256)',
      'function realEth() view returns (uint256)',
      'function realToken() view returns (uint256)'
    ];
    // ERC20 å…ƒæ•°æ® ABIï¼ˆç”¨äºå…œåº•è¯»å– name/symbolï¼‰
    const ERC20_METADATA_ABI = [
      'function name() view returns (string)',
      'function symbol() view returns (string)',
      'function totalSupply() view returns (uint256)',
      'function decimals() view returns (uint8)'
    ];

                   // å…¨å±€å˜é‡
      let provider, signer, factoryContract;
      let readProvider, factoryReadContract;
      let routerContract;
      let isConnected = false;
      let deployedTokens = [];
      let tokenData = {};
             let monitoredAddresses = new Set();
       let okayMonitoredAddresses = new Set(); // OKAYç›‘æ§çš„ä»£å¸åœ°å€
       let statusUpdateInterval;
       let priceUpdateInterval;
              let currentBuyToken = null; // å½“å‰è¦è´­ä¹°çš„ä»£å¸
        let historyRecords = []; // å†å²è®°å½•æ•°ç»„
      
             // æœ¬åœ°å­˜å‚¨é”®å
       const STORAGE_KEYS = {
         MONITORED_TOKENS: 'pumpu_monitored_tokens',
         OKAY_MONITORED_TOKENS: 'pumpu_okay_monitored_tokens',
         USER_PREFERENCES: 'pumpu_user_preferences',
         TOKEN_HISTORY: 'pumpu_token_history',
         HISTORY_RECORDS: 'pumpu_history_records'
       };
     
     // ç”¨æˆ·åå¥½è®¾ç½®
     let userPreferences = {
       soundEnabled: true,
       notificationEnabled: true,
       autoRefresh: true,
       priceChangeThreshold: 0.1, // 10% ä»·æ ¼å˜åŒ–æé†’
       minLiquidityThreshold: 50
     };

                  // åˆå§‹åŒ–
         async function init() {
           try {
             // åŠ è½½æœ¬åœ°å­˜å‚¨çš„æ•°æ®
             loadLocalData();
             
                                            // ä» Firebase åŠ è½½ä»£å¸æ•°æ®
                console.log('ğŸ”„ æ­£åœ¨ä» Firebase åŠ è½½æ•°æ®...');
                updateSyncStatus('ğŸ”„', 'åŠ è½½ä¸­...');
                const firebaseData = await loadFromFirebase('pumpu_tokens');
                if (firebaseData) {
                  deployedTokens = firebaseData.tokens || [];
                  tokenData = firebaseData.tokenData || [];
                  monitoredAddresses = new Set(firebaseData.monitoredAddresses || []);
                  console.log(`âœ… ä» Firebase åŠ è½½äº† ${deployedTokens.length} ä¸ªä»£å¸`);
                  
                  // æ›´æ–°UIæ˜¾ç¤º
                  updateTokenDisplay();
                  updateSyncStatus('âœ…', 'æ•°æ®å·²åŠ è½½');
                  
                  // é»˜è®¤æ˜¾ç¤ºé¦–é¡µï¼ˆä¸‰ä¸ªåˆ—åŒæ—¶æ˜¾ç¤ºï¼‰
                  showHome();
                } else {
                  updateSyncStatus('â„¹ï¸', 'æ— å†å²æ•°æ®');
                  
                  // å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿæ˜¾ç¤ºé¦–é¡µ
                  showHome();
                }
                
                // ä» Firebase åŠ è½½OKAYç›‘æ§ä»£å¸æ•°æ®
                const okayFirebaseData = await loadFromFirebase('pumpu_okay_tokens');
                if (okayFirebaseData && okayFirebaseData.okayMonitoredAddresses) {
                  okayMonitoredAddresses = new Set(okayFirebaseData.okayMonitoredAddresses);
                  console.log(`âœ… ä» Firebase åŠ è½½äº† ${okayMonitoredAddresses.size} ä¸ªOKAYç›‘æ§ä»£å¸`);
                  updateOkayMonitoringDisplay();
                }
                
                // åŠ è½½å†å²è®°å½•
                await loadHistoryRecords();
             
             // æ£€æŸ¥æ˜¯å¦å®‰è£…äº†MetaMask
             // å§‹ç»ˆåˆå§‹åŒ–åªè¯»Providerï¼Œä¾¿äºæœªè¿æ¥é’±åŒ…ä¹Ÿèƒ½çœ‹åˆ°æ•°æ®
             try {
               readProvider = new ethers.providers.JsonRpcProvider(CONFIG.XLAYER_RPC);
               console.log('ä½¿ç”¨ä¸»RPCç«¯ç‚¹:', CONFIG.XLAYER_RPC);
             } catch (error) {
               console.warn('ä¸»RPCç«¯ç‚¹å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨ç«¯ç‚¹:', error);
               try {
                 readProvider = new ethers.providers.JsonRpcProvider(CONFIG.XLAYER_RPC_BACKUP);
                 console.log('ä½¿ç”¨å¤‡ç”¨RPCç«¯ç‚¹:', CONFIG.XLAYER_RPC_BACKUP);
               } catch (backupError) {
                 console.error('æ‰€æœ‰RPCç«¯ç‚¹éƒ½å¤±è´¥:', backupError);
                 throw new Error('æ— æ³•è¿æ¥åˆ°åŒºå—é“¾ç½‘ç»œ');
               }
             }
             factoryReadContract = new ethers.Contract(
               CONFIG.PUMPU_FACTORY,
               CONFIG.PUMPU_FACTORY_ABI,
               readProvider
             );

            if (typeof window.ethereum !== 'undefined') {
              provider = new ethers.providers.Web3Provider(window.ethereum);
              
              // ç›‘å¬è´¦æˆ·å˜åŒ–
              window.ethereum.on('accountsChanged', function (accounts) {
                if (accounts.length === 0) {
                  disconnectWallet();
                } else {
                  updateWalletInfo(accounts[0]);
                }
              });

              // ç›‘å¬é“¾å˜åŒ–
              window.ethereum.on('chainChanged', function (chainId) {
                if (chainId !== CONFIG.XLAYER_CHAIN_ID_HEX) {
                  console.warn('å½“å‰ä¸æ˜¯XLayerä¸»ç½‘ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨');
                }
              });

              console.log('Web3 provider initialized');
            } else {
              console.log('MetaMask æœªå®‰è£…ï¼Œå°†ä»…ä½¿ç”¨åªè¯»æ¨¡å¼');
            }

                 // æ— è®ºæ˜¯å¦è¿æ¥é’±åŒ…ï¼Œéƒ½å¼€å§‹åªè¯»ç›‘å¬
             startReadonlyMonitoring();
             
             // å¯åŠ¨çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
             startStatusUpdates();
             
             // å¯åŠ¨ä»·æ ¼ç›‘æ§
             startPriceMonitoring();
            
                         // å¯åŠ¨åè‡ªåŠ¨å°è¯•å›å¡«ç¼ºå¤±å…ƒæ•°æ®ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œé¿å…é˜»å¡ï¼‰
             setTimeout(() => {
               try { 
                 backfillMissingMeta(); 
                 // åŒæ­¥ä»£å¸åç§°æ•°æ®
                 syncTokenNames();
               } catch (e) { console.warn('è‡ªåŠ¨å›å¡«å…ƒæ•°æ®å¤±è´¥:', e); }
             }, 3000);
           } catch (error) {
             console.error('åˆå§‹åŒ–å¤±è´¥:', error);
           }
         }

    // è¿æ¥é’±åŒ…
    async function connectWallet() {
      try {
        if (!provider) {
          alert('è¯·å…ˆå®‰è£…MetaMask');
          return;
        }

        const accounts = await provider.send("eth_requestAccounts", []);
        if (accounts.length > 0) {
          isConnected = true;
          signer = provider.getSigner();
          updateWalletInfo(accounts[0]);
          
          // åˆå§‹åŒ–åˆçº¦
          await initContracts();
          
          // å¼€å§‹ç›‘å¬ï¼ˆå¸¦ç­¾åè€…ï¼Œä»…å½“éœ€è¦å†™æ“ä½œæ—¶ï¼‰
          startListening();
        }
      } catch (error) {
        console.error('è¿æ¥é’±åŒ…å¤±è´¥:', error);
        alert('è¿æ¥é’±åŒ…å¤±è´¥: ' + error.message);
      }
    }

    // æ–­å¼€é’±åŒ…è¿æ¥
    function disconnectWallet() {
      isConnected = false;
      signer = null;
      updateWalletInfo(null);
      stopListening();
    }

    // æ›´æ–°é’±åŒ…ä¿¡æ¯æ˜¾ç¤º
    function updateWalletInfo(address) {
      const walletSection = document.getElementById('wallet-section');
      if (address) {
        walletSection.innerHTML = `
          <div class="wallet-info">
            <span class="wallet-address">${address.substring(0, 6)}...${address.substring(38)}</span>
            <button class="connect-wallet" onclick="disconnectWallet()">æ–­å¼€</button>
          </div>
        `;
      } else {
        walletSection.innerHTML = `
          <button class="refresh-btn" onclick="connectWallet()">è¿æ¥é’±åŒ…</button>
        `;
      }
    }

         // åˆå§‹åŒ–åˆçº¦
     async function initContracts() {
       try {
         factoryContract = new ethers.Contract(
           CONFIG.PUMPU_FACTORY,
           CONFIG.PUMPU_FACTORY_ABI,
           signer
         );
         
         // åˆå§‹åŒ– Router åˆçº¦
         routerContract = new ethers.Contract(
           CONFIG.PUMPU_ROUTER,
           CONFIG.ROUTER_ABI,
           signer
         );
         
         console.log('åˆçº¦åˆå§‹åŒ–æˆåŠŸ');
       } catch (error) {
         console.error('åˆçº¦åˆå§‹åŒ–å¤±è´¥:', error);
       }
     }

    // å¼€å§‹ç›‘å¬æ–°ä»£å¸
    async function startListening() {
      try {
        // ç›‘å¬Deployedäº‹ä»¶
        factoryContract.on('Deployed', async (addr, amount) => {
          console.log('æ–°ä»£å¸éƒ¨ç½²:', addr, amount);
          await addNewToken(addr, amount);
        });

        console.log('å¼€å§‹ç›‘å¬æ–°ä»£å¸');
      } catch (error) {
        console.error('ç›‘å¬å¤±è´¥:', error);
      }
    }

    // åœæ­¢ç›‘å¬
    function stopListening() {
      if (factoryContract) {
        factoryContract.removeAllListeners();
      }
      if (factoryReadContract) {
        factoryReadContract.removeAllListeners();
      }
    }

    // åªè¯»ç›‘å¬ + å›æº¯æœ€è¿‘äº‹ä»¶
    async function startReadonlyMonitoring() {
      try {
        if (!factoryReadContract) return;

        // å®æ—¶äº‹ä»¶
        factoryReadContract.on('Deployed', async (addr, amount) => {
          console.log('[åªè¯»] æ–°ä»£å¸éƒ¨ç½²:', addr, amount);
          await addNewToken(addr, amount);
        });

                 // å›æº¯æœ€è¿‘Nä¸ªåŒºå—å†…çš„äº‹ä»¶ï¼ˆé™åˆ¶åœ¨100ä¸ªåŒºå—å†…ï¼‰
         const latest = await readProvider.getBlockNumber();
         const lookback = 100; // é™åˆ¶åœ¨100ä¸ªåŒºå—å†…ï¼Œé¿å…RPCé”™è¯¯
         const fromBlock = Math.max(0, latest - lookback);
        const filter = factoryReadContract.filters.Deployed();
        const logs = await factoryReadContract.queryFilter(filter, fromBlock, latest);
        for (const log of logs) {
          const addr = log.args && log.args[0];
          const amount = log.args && log.args[1] ? log.args[1] : 0;
          if (addr && !tokenData[addr]) {
            await addNewToken(addr, amount);
          }
        }

        console.log('åªè¯»ç›‘æ§å·²å¯åŠ¨ï¼ŒåŒºå—:', fromBlock, 'â†’', latest, 'äº‹ä»¶æ•°:', logs.length);
      } catch (error) {
        console.error('åªè¯»ç›‘æ§å¤±è´¥:', error);
      }
    }

    // æ·»åŠ æ–°ä»£å¸
    async function addNewToken(address, amount) {
      try {
        const tokenContract = new ethers.Contract(
          address,
          CONFIG.PUMP_TOKEN_ABI,
          readProvider
        );

        // è·å–ä»£å¸ä¿¡æ¯
        const [description, image, website, telegram, twitter] = await Promise.all([
          tokenContract.description().catch(() => ''),
          tokenContract.image().catch(() => ''),
          tokenContract.website().catch(() => ''),
          tokenContract.telegram().catch(() => ''),
          tokenContract.twitter().catch(() => '')
        ]);

        const tokenInfo = {
          address,
          description,
          image,
          website,
          telegram,
          twitter,
          amount: ethers.utils.formatEther(amount),
          timestamp: Date.now(),
          status: 'new',
          price: 0,
          liquidity: 0,
          holderCount: 0,
          tradeVolume: 0,
          lastStatusUpdate: Date.now()
        };

        // ä¼˜å…ˆå°è¯•ä»åˆçº¦è¯»å–çœŸå®çš„åç§°å’Œç¬¦å·
        try {
          const erc20Contract = new ethers.Contract(address, ERC20_METADATA_ABI, readProvider);
          const [name, symbol] = await Promise.all([
            erc20Contract.name().catch(() => ''),
            erc20Contract.symbol().catch(() => '')
          ]);
          
          if (name && typeof name === 'string' && name.trim()) {
            tokenInfo.name = name.trim();
          }
          if (symbol && typeof symbol === 'string' && symbol.trim()) {
            tokenInfo.symbol = symbol.trim();
          }
        } catch (e) {
          console.warn('æ— æ³•ä»åˆçº¦è¯»å–åç§°/ç¬¦å·:', e);
        }
        
        // å¦‚æœåˆçº¦ä¸­æ²¡æœ‰åç§°ï¼Œæ‰å°è¯•ä»æè¿°ä¸­æå–ï¼ˆå…œåº•ï¼‰
        if (!tokenInfo.name || !tokenInfo.symbol) {
          const metaGuess = extractNameSymbolFromDescription(description);
          if (metaGuess.name && !tokenInfo.name) tokenInfo.name = metaGuess.name;
          if (metaGuess.symbol && !tokenInfo.symbol) tokenInfo.symbol = metaGuess.symbol;
        }

        // ç¡®ä¿ä¸¤ä¸ªæ•°æ®æºéƒ½åŒ…å«å®Œæ•´çš„ä»£å¸ä¿¡æ¯
        tokenData[address] = tokenInfo;
        deployedTokens.push(tokenInfo);
        
        // å¼ºåˆ¶åŒæ­¥åç§°å’Œç¬¦å·åˆ°ä¸¤ä¸ªæ•°æ®æº
        if (tokenInfo.name) {
          tokenData[address].name = tokenInfo.name;
        }
        if (tokenInfo.symbol) {
          tokenData[address].symbol = tokenInfo.symbol;
        }

        // å¼‚æ­¥è§£æ DYOR ä»£å¸å¤´åƒï¼ˆä»…å¯¹ DYOR ç”Ÿæ•ˆï¼‰
        (async () => {
          try {
            if (tokenInfo.source !== 'okay-monitoring') {
              const imgUrl = await resolveDYORTokenImage(address);
              if (imgUrl) {
                tokenData[address].image = imgUrl;
                // è½»é‡åˆ·æ–°å½“å‰åˆ—
                updateTokenDisplay();
              }
            }
          } catch (e) {
            console.warn('DYOR å¤´åƒè§£æä»»åŠ¡å¤±è´¥:', e);
          }
        })();

        // æ›´æ–°UI
        updateTokenDisplay();
        
        // ä¿å­˜åˆ° Firebase
        await saveToFirebase({
          tokens: deployedTokens,
          tokenData: tokenData,
          lastUpdated: Date.now()
        }, 'pumpu_tokens');
        
                 console.log('æ–°ä»£å¸æ·»åŠ æˆåŠŸ:', tokenInfo);
         
         // æ·»åŠ å†å²è®°å½•
         addHistoryRecord('created', `æ–°ä»£å¸åˆ›å»º: ${tokenInfo.description || 'Unknown Token'}`, address, {
           amount: tokenInfo.amount,
           description: tokenInfo.description
         });
         
         // ç«‹å³æ£€æŸ¥ä¸€æ¬¡çŠ¶æ€
         setTimeout(() => checkTokenStatus(address), 5000);
      } catch (error) {
        console.error('æ·»åŠ æ–°ä»£å¸å¤±è´¥:', error);
      }
    }

    // æ›´æ–°ä»£å¸æ˜¾ç¤º
         function updateTokenDisplay() {
      // æŒ‰æ—¶é—´æ’åº
      deployedTokens.sort((a, b) => b.timestamp - a.timestamp);
      
      // åŒæ­¥ä»£å¸åç§°æ•°æ®
      syncTokenNames();
      
      // æ¸²æŸ“å‰å°è¯•è¡¥å…¨ç¼ºå¤±å¤´åƒä¸åç§°/ç¬¦å·ï¼ˆä»… DYORï¼‰
      try {
        deployedTokens.forEach(t => {
          if (t.source !== 'okay-monitoring') {
            if (!t.image) { ensureDYORImage(t.address); }
            if (!t.name || !t.symbol) { ensureDYORMeta(t.address); }
          }
        });
      } catch (e) { console.warn('é¢„è§£æ DYOR å…ƒä¿¡æ¯å¤±è´¥:', e); }
      
      // æ›´æ–°å„åˆ—æ˜¾ç¤ºï¼ˆæ··åˆä¸¤ä¸ªå‘å°„å°çš„ä»£å¸ï¼‰
      updateColumnDisplay('new-tokens', deployedTokens.filter(t => t.status === 'new'));
      updateColumnDisplay('pending-tokens', deployedTokens.filter(t => t.status === 'pending'));
      updateColumnDisplay('opened-tokens', deployedTokens.filter(t => t.status === 'opened'));
      updateMonitoringDisplay();
      updateOkayMonitoringDisplay();
    }

         function updateMonitoringDisplay() {
       const tokens = deployedTokens.filter(t => t.isMonitored);
       updateColumnDisplay('monitoring-tokens', tokens);
     }
     
     function updateOkayMonitoringDisplay() {
       const tokens = deployedTokens.filter(t => okayMonitoredAddresses.has(t.address));
       updateColumnDisplay('okay-monitoring-tokens', tokens);
     }

         // æ›´æ–°åˆ—æ˜¾ç¤º
     function updateColumnDisplay(columnId, tokens) {
       const column = document.getElementById(columnId);
       if (tokens.length === 0) {
         column.innerHTML = `
           <h2>${getColumnTitle(columnId)}</h2>
           <div class="loading">æš‚æ— æ•°æ®</div>
         `;
         return;
       }

       let html = `<h2>${getColumnTitle(columnId)}</h2>`;
       
               // ä¸ºå‘å°„å°ç›‘æ§æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
        if (columnId === 'monitoring-tokens') {
         html += createLaunchpadStats('dyor', tokens);
       } else if (columnId === 'okay-monitoring-tokens') {
         html += createLaunchpadStats('okay', tokens);
       }
       
       tokens.forEach(token => {
         html += createTokenCard(token);
       });
       column.innerHTML = html;
     }

                  // è·å–åˆ—æ ‡é¢˜
      function getColumnTitle(columnId) {
        const titles = {
          'new-tokens': 'æ–°åˆ›å»º',
          'pending-tokens': 'å³å°†æ‰“æ»¡',
          'opened-tokens': 'å·²å¼€ç›˜',
          'monitoring-tokens': 'DYORå‘å°„å°ç›‘æ§',
          'okay-monitoring-tokens': 'OKAYå‘å°„å°ç›‘æ§',
          'history-tokens': 'å†å²è®°å½•'
        };
        return titles[columnId] || '';
      }

         // åˆ›å»ºä»£å¸å¡ç‰‡
     function createTokenCard(token) {
       const statusClass = getStatusClass(token.status);
       const statusText = getStatusText(token.status);
       
       // æ£€æŸ¥æ˜¯å¦æ˜¯OKAYç›‘æ§çš„ä»£å¸
       const isOkayMonitored = okayMonitoredAddresses.has(token.address);
       
       // ç¡®å®šå‘å°„å°ç±»å‹å’Œæ ·å¼
       let launchpadBadge = '';
       let launchpadClass = '';
       
       if (isOkayMonitored) {
         launchpadBadge = 'OKAYå‘å°„å°';
         launchpadClass = 'okay-launchpad';
       } else if (token.source === 'okay-monitoring') {
         launchpadBadge = 'OKAYå‘å°„å°';
         launchpadClass = 'okay-launchpad';
       } else {
         launchpadBadge = 'DYORå‘å°„å°';
         launchpadClass = 'dyor-launchpad';
       }
       
       return `
         <div class="card ${launchpadClass}" onclick="showTokenDetails('${token.address}')">
           <div class="avatar">
             ${(() => { const normalized = normalizeImageUrl(token.image); const avatarUrl = normalized || generateAddressIdenticon(token.address); return `<img src="${avatarUrl}" alt="Logo" onerror="this.style.display='none'; if(this.nextSibling) this.nextSibling.style.display='flex';"><div style=\"display:none;\">${token.description ? token.description.charAt(0).toUpperCase() : 'T'}</div>`; })()}
           </div>
           <div class="info">
             <div class="title">
               <span class="status-indicator ${statusClass}"></span>
               ${token.name || token.symbol || (token.description && !token.description.startsWith('http') ? token.description : 'Unknown Token')}
               ${token.symbol && token.symbol !== token.name ? `<span style=\"margin-left:6px;color:#aaa;font-weight:normal;font-size:12px;\">(${token.symbol})</span>` : ''}
               <span class="launchpad-badge ${launchpadClass}">${launchpadBadge}</span>
             </div>
             <div class="desc">
               ${token.address.substring(0, 8)}...${token.address.substring(36)}<br/>
               åˆ›å»ºæ—¶é—´: ${new Date(token.timestamp).toLocaleString()}<br/>
               ${token.amount ? `åˆå§‹é‡‘é¢: ${token.amount} OKB<br/>` : ''}
               ${token.status === 'opened' ? `ä»·æ ¼: ${token.price ? token.price.toFixed(6) + ' OKB' : 'è·å–ä¸­...'}<br/>` : ''}
               ${token.status === 'opened' ? `æ± å­OKB: ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : 'è·å–ä¸­...'}<br/>` : ''}
               ${token.status === 'opened' ? `å¸‚å€¼: ${token.marketCap ? formatMarketCap(token.marketCap) : 'è·å–ä¸­...'}` : ''}
               ${token.status === 'pending' ? `å³å°†å¼€ç›˜: æµåŠ¨æ€§ ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : 'è·å–ä¸­...'}<br/>` : ''}
               ${token.status === 'opened' && launchpadClass === 'dyor-launchpad' && token.priceChange !== undefined ? 
                 `<span class="price-change ${token.priceChange >= 0 ? 'positive' : 'negative'}">
                   ${token.priceChange >= 0 ? '+' : ''}${token.priceChange.toFixed(2)}%
                 </span><br/>` : ''
               }
               ${token.status === 'opened' && launchpadClass === 'dyor-launchpad' && token.lastPriceUpdate ? 
                 `æ›´æ–°æ—¶é—´: ${new Date(token.lastPriceUpdate).toLocaleTimeString()}<br/>` : ''
               }
             </div>
           </div>
           <div class="stats">
             ${token.status === 'opened' ? 
               `<div style="margin-bottom: 5px; color: #00ff00;">å·²å¼€ç›˜</div>` : 
               `<div style="margin-bottom: 5px; color: #ffaa00;">${token.status === 'pending' ? 'å³å°†æ‰“æ»¡' : 'æ–°åˆ›å»º'}</div>`
             }
             <span class="buy-btn">æŸ¥çœ‹è¯¦æƒ…</span>
             ${isOkayMonitored ? `<button class="refresh-btn" onclick="removeFromOkayMonitoring('${token.address}')" style="margin-left: 5px; background: #ff4444;">ç§»é™¤</button>` : ''}
             ${!isOkayMonitored && token.status === 'opened' ? `<button class="refresh-btn" onclick="refreshDYORTokenPrice('${token.address}')" style="margin-left: 5px; background: #00d8ff; font-size: 10px;">åˆ·æ–°ä»·æ ¼</button>` : ''}
           </div>
         </div>
       `;
     }

    // è·å–çŠ¶æ€æ ·å¼ç±»
    function getStatusClass(status) {
      const classes = {
        'new': 'status-live',
        'pending': 'status-pending',
        'opened': 'status-closed'
      };
      return classes[status] || 'status-pending';
    }

    // è·å–çŠ¶æ€æ–‡æœ¬
    function getStatusText(status) {
      const texts = {
        'new': 'æ–°åˆ›å»º',
        'pending': 'å³å°†æ‰“æ»¡',
        'opened': 'å·²å¼€ç›˜'
      };
      return texts[status] || 'æœªçŸ¥';
    }

    // è§„èŒƒåŒ–å›¾ç‰‡ URLï¼ˆæ”¯æŒ ipfs://ã€/ipfs/ã€è£¸ CIDï¼‰
    function normalizeImageUrl(raw) {
      try {
        if (!raw || typeof raw !== 'string') return '';
        const trimmed = raw.trim();
        if (trimmed.startsWith('http://') || trimmed.startsWith('https://') || trimmed.startsWith('data:')) {
          return trimmed;
        }
        const gateway = 'https://ipfs.io/ipfs/';
        if (trimmed.startsWith('ipfs://ipfs/')) {
          return gateway + trimmed.replace('ipfs://ipfs/', '');
        }
        if (trimmed.startsWith('ipfs://')) {
          return gateway + trimmed.replace('ipfs://', '');
        }
        if (trimmed.startsWith('/ipfs/')) {
          return gateway + trimmed.replace('/ipfs/', '');
        }
        // ç²—ç•¥åˆ¤æ–­è£¸ CIDï¼ˆCIDv0 ä»¥ Qm å¼€å¤´ï¼ŒCIDv1 å¸¸ä»¥ bafy å¼€å¤´ï¼‰
        const looksLikeCid = /^Qm[1-9A-Za-z]{44,}|^bafy[1-9A-Za-z]{20,}/.test(trimmed);
        if (looksLikeCid) {
          return gateway + trimmed;
        }
        return trimmed;
      } catch (e) {
        return '';
      }
    }

    // ç”Ÿæˆåœ°å€ Identiconï¼ˆSVG base64ï¼‰
    function generateAddressIdenticon(address) {
      try {
        const seed = (address || '').toString().toLowerCase();
        let hash = 0;
        for (let i = 0; i < seed.length; i++) {
          hash = ((hash << 5) - hash) + seed.charCodeAt(i);
          hash |= 0;
        }
        const hue = Math.abs(hash) % 360;
        const color = `hsl(${hue},70%,50%)`;
        const bg = '#1e1e1e';
        const size = 64;
        const cell = size / 5;
        let rects = '';
        for (let y = 0; y < 5; y++) {
          for (let x = 0; x < 3; x++) {
            const bitIndex = (y * 3 + x) % 31;
            const bit = (hash >> bitIndex) & 1;
            if (bit) {
              const px = x * cell;
              const py = y * cell;
              rects += `<rect x='${px}' y='${py}' width='${cell}' height='${cell}' fill='${color}'/>`;
              const mirrX = (4 - x) * cell;
              rects += `<rect x='${mirrX}' y='${py}' width='${cell}' height='${cell}' fill='${color}'/>`;
            }
          }
        }
        const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'><rect width='100%' height='100%' fill='${bg}'/>${rects}</svg>`;
        return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
      } catch (e) {
        return '';
      }
    }

    // æ˜¾ç¤ºä»£å¸è¯¦æƒ…
    function showTokenDetails(address) {
      // ä¼˜å…ˆä» deployedTokens ä¸­æŸ¥æ‰¾ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
      let token = deployedTokens.find(t => t.address === address);
      if (!token) {
        token = tokenData[address];
      }
      if (!token) return;

      const modal = document.getElementById('tokenModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalDetails = document.getElementById('modalDetails');

      modalTitle.textContent = token.name || token.symbol || (token.description && !token.description.startsWith('http') ? token.description : 'ä»£å¸è¯¦æƒ…');
      modalDetails.innerHTML = `
        <div class="detail-item">
          <h4>åŸºæœ¬ä¿¡æ¯</h4>
          <p><strong>åç§°:</strong> ${token.name || 'â€”'}</p>
          <p><strong>ç¬¦å·:</strong> ${token.symbol || 'â€”'}</p>
          <p><strong>ç®€ä»‹:</strong> ${token.description && !token.description.startsWith('http') ? token.description : 'â€”'}</p>
          <p><strong>åœ°å€:</strong> ${token.address}</p>
          <p><strong>åˆ›å»ºæ—¶é—´:</strong> ${new Date(token.timestamp).toLocaleString()}</p>
          <p><strong>åˆå§‹é‡‘é¢:</strong> ${token.amount} OKB</p>
        </div>
        <div class="detail-item">
          <h4>é“¾æ¥</h4>
          <p><strong>ç½‘ç«™:</strong> ${token.website && !token.website.startsWith('http') ? token.website : (token.website ? `<a href="${token.website}" target="_blank">${token.website}</a>` : 'æ— ')}</p>
          <p><strong>Telegram:</strong> ${token.telegram ? `<a href="${token.telegram}" target="_blank">${token.telegram}</a>` : 'æ— '}</p>
          <p><strong>Twitter:</strong> ${token.twitter ? `<a href="${token.twitter}" target="_blank">${token.twitter}</a>` : 'æ— '}</p>
        </div>
                 <div class="detail-item">
           <h4>æ“ä½œ</h4>
           <button class="buy-btn" onclick="showBuyInterface('${token.address}')">ä¹°å…¥ä»£å¸</button>
           <button class="refresh-btn" onclick="addToMonitoring('${token.address}')">æ·»åŠ åˆ°ç›‘æ§</button>
           ${token.status === 'opened' || token.status === 'pending' ? `<button class="refresh-btn" onclick="showPoolDetails('${token.address}')" style="margin-top: 5px; background: #00d8ff;">æŸ¥çœ‹æ± å­è¯¦æƒ…</button>` : ''}
         </div>
        <div class="detail-item">
          <h4>å¸‚åœºæ•°æ®</h4>
          ${token.status === 'opened' ? `
            <p><strong>ä»·æ ¼:</strong> ${token.price ? token.price.toFixed(6) + ' OKB' : 'è·å–ä¸­...'}</p>
            <p><strong>æ± å­OKB:</strong> ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : 'è·å–ä¸­...'}</p>
            <p><strong>å¸‚å€¼:</strong> ${token.marketCap ? formatMarketCap(token.marketCap) : 'è·å–ä¸­...'}</p>
            <p><strong>æ€»ä¾›åº”é‡:</strong> ${token.totalSupply ? token.totalSupply.toLocaleString() : 'è·å–ä¸­...'}</p>
          ` : token.status === 'pending' ? `
            <p><strong>å³å°†å¼€ç›˜:</strong> <span style="color: #ffaa00;">æµåŠ¨æ€§æ¥è¿‘å¼€ç›˜æ¡ä»¶</span></p>
            <p><strong>å½“å‰æµåŠ¨æ€§:</strong> ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : 'è·å–ä¸­...'}</p>
            <p><strong>å¼€ç›˜æ¡ä»¶:</strong> ${OPENING_DETECTION_CONFIG.OPENING_CONDITIONS.MIN_LIQUIDITY_OKB} OKB</p>
            <p style="color: #ffaa00;">âš ï¸ ä»£å¸å³å°†å¼€ç›˜ï¼Œè¯·å¯†åˆ‡å…³æ³¨</p>
          ` : '<p>ä»£å¸å°šæœªå¼€ç›˜ï¼Œæš‚æ— å¸‚åœºæ•°æ®</p>'}
        </div>
        <div class="detail-item">
          <h4>çŠ¶æ€</h4>
          <p><strong>å½“å‰çŠ¶æ€:</strong> <span class="status-indicator ${getStatusClass(token.status)}"></span>${getStatusText(token.status)}</p>
          <button class="refresh-btn" onclick="updateTokenStatus('${token.address}')">æ›´æ–°çŠ¶æ€</button>
        </div>
      `;

      modal.style.display = 'block';
    }

    // å…³é—­æ¨¡æ€æ¡†
    function closeModal() {
      document.getElementById('tokenModal').style.display = 'none';
    }

         // æ˜¾ç¤ºè´­ä¹°ç•Œé¢
     function showBuyInterface(address) {
       if (!isConnected) {
         alert('è¯·å…ˆè¿æ¥é’±åŒ…');
         return;
       }
       
       currentBuyToken = tokenData[address];
       if (!currentBuyToken) {
         alert('ä»£å¸ä¿¡æ¯ä¸å­˜åœ¨');
         return;
       }
       
       const buyModal = document.getElementById('buyModal');
       const buyModalTitle = document.getElementById('buyModalTitle');
       const buyModalContent = document.getElementById('buyModalContent');
       
       buyModalTitle.textContent = `è´­ä¹° ${currentBuyToken.description || 'ä»£å¸'}`;
       
               buyModalContent.innerHTML = `
          <div class="buy-interface">
            <div class="buy-input-group">
              <label>è´­ä¹°é‡‘é¢ (OKB)</label>
              <input type="number" id="buyAmount" placeholder="è¾“å…¥è´­ä¹°é‡‘é¢" min="0.01" step="0.01" value="0.01" oninput="updateBuyPreview()">
            </div>
            
            <div class="buy-input-group">
              <label>æ»‘ç‚¹å®¹å¿åº¦ (%)</label>
              <input type="number" id="slippage" class="slippage-input" value="5" min="0.1" max="50" step="0.1">
            </div>
            
            <div class="buy-preview" id="buyPreview">
              <h4>äº¤æ˜“é¢„è§ˆ</h4>
              <p>è¯·å…ˆè¾“å…¥è´­ä¹°é‡‘é¢</p>
            </div>
            
            <div class="buy-actions">
              <button class="buy-confirm-btn" id="confirmBuyBtn" onclick="buyToken()" disabled>ç¡®è®¤è´­ä¹°</button>
              <button class="refresh-btn" onclick="closeBuyModal()">å–æ¶ˆ</button>
            </div>
          </div>
        `;
       
       buyModal.style.display = 'block';
     }
     
     // å…³é—­è´­ä¹°æ¨¡æ€æ¡†
     function closeBuyModal() {
       document.getElementById('buyModal').style.display = 'none';
       currentBuyToken = null;
     }
     
     // æ›´æ–°è´­ä¹°é¢„è§ˆ
     async function updateBuyPreview() {
       const amountInput = document.getElementById('buyAmount');
       const preview = document.getElementById('buyPreview');
       const confirmBtn = document.getElementById('confirmBuyBtn');
       
       const amount = parseFloat(amountInput.value);
       if (!amount || amount <= 0) {
         preview.innerHTML = '<h4>äº¤æ˜“é¢„è§ˆ</h4><p>è¯·å…ˆè¾“å…¥è´­ä¹°é‡‘é¢</p>';
         confirmBtn.disabled = true;
         return;
       }
       
       try {
         // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
         preview.innerHTML = '<h4>äº¤æ˜“é¢„è§ˆ</h4><p>ğŸ”„ è®¡ç®—ä¸­...</p>';
         
         // è®¡ç®—é¢„ä¼°ä»£å¸æ•°é‡
         const estimatedTokens = await calculateEstimatedTokens(amount);
         
         preview.innerHTML = `
           <h4>äº¤æ˜“é¢„è§ˆ</h4>
           <p><strong>æ”¯ä»˜:</strong> ${amount.toFixed(4)} OKB</p>
           <p><strong>é¢„è®¡è·å¾—:</strong> ${estimatedTokens.toFixed(2)} ä»£å¸</p>
           <p><strong>æ»‘ç‚¹:</strong> ${document.getElementById('slippage').value}%</p>
           <p><strong>ä»£å¸åœ°å€:</strong> ${currentBuyToken.address.substring(0, 8)}...${currentBuyToken.address.substring(36)}</p>
         `;
         
         confirmBtn.disabled = false;
       } catch (error) {
         preview.innerHTML = `
           <h4>äº¤æ˜“é¢„è§ˆ</h4>
           <p style="color: #ff4444;">âŒ è®¡ç®—å¤±è´¥: ${error.message}</p>
         `;
         confirmBtn.disabled = true;
       }
     }
     
           // è®¡ç®—é¢„ä¼°ä»£å¸æ•°é‡
      async function calculateEstimatedTokens(ethAmount) {
        try {
          if (!routerContract) {
            throw new Error('Routeråˆçº¦æœªåˆå§‹åŒ–');
          }
          
          const path = [CONFIG.WOKB, currentBuyToken.address];
          const amountIn = ethers.utils.parseEther(ethAmount.toString());
          
          const amounts = await routerContract.getAmountsOut(amountIn, path);
          const tokenAmount = amounts[1];
          
          return parseFloat(ethers.utils.formatUnits(tokenAmount, 18));
        } catch (error) {
          console.error('è®¡ç®—é¢„ä¼°ä»£å¸æ•°é‡å¤±è´¥:', error);
          throw new Error('æ— æ³•è®¡ç®—é¢„ä¼°æ•°é‡ï¼Œè¯·æ£€æŸ¥ä»£å¸åˆçº¦');
        }
      }
      
      // æ‰§è¡Œä¹°å…¥ä»£å¸
      async function buyToken() {
        if (!isConnected || !currentBuyToken || !routerContract) {
          alert('è¯·å…ˆè¿æ¥é’±åŒ…å¹¶é€‰æ‹©ä»£å¸');
          return;
        }
        
        const buyAmountInput = document.getElementById('buyAmount');
        const slippageInput = document.getElementById('slippage');
        const confirmBtn = document.getElementById('confirmBuyBtn');
        
        const buyAmount = parseFloat(buyAmountInput.value);
        const slippage = parseFloat(slippageInput.value);
        
        if (isNaN(buyAmount) || buyAmount <= 0) {
          alert('è¯·è¾“å…¥æœ‰æ•ˆçš„è´­ä¹°é‡‘é¢');
          return;
        }
        if (isNaN(slippage) || slippage < 0 || slippage > 100) {
          alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ»‘ç‚¹å®¹å¿åº¦ (0-100)');
          return;
        }
        
        confirmBtn.disabled = true;
        confirmBtn.textContent = 'äº¤æ˜“ä¸­...';
        
        try {
          const amountIn = ethers.utils.parseEther(buyAmount.toString());
          const path = [CONFIG.WOKB, currentBuyToken.address];
          
          // é¢„ä¼°è·å¾—ä»£å¸æ•°é‡
          const amounts = await routerContract.getAmountsOut(amountIn, path);
          const amountOutMin = amounts[1];
          
          // è®¡ç®—æ»‘ç‚¹åçš„æœ€å°æ¥æ”¶æ•°é‡
          const minAmountOutWithSlippage = amountOutMin.mul(10000 - Math.floor(slippage * 100)).div(10000);
          
          const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20åˆ†é’Ÿåæˆªæ­¢
          
          // æ‰§è¡Œäº¤æ˜“
          const tx = await routerContract.swapExactETHForTokens(
            minAmountOutWithSlippage,
            path,
            await signer.getAddress(), // æ¥æ”¶ä»£å¸çš„åœ°å€
            deadline,
            { value: amountIn } // å‘é€çš„OKBæ•°é‡
          );
          
          showNotification(`äº¤æ˜“å·²å‘é€ï¼Œå“ˆå¸Œ: ${tx.hash.substring(0, 10)}...`, 'success');
          
          const receipt = await tx.wait();
          
          if (receipt.status === 1) {
            showNotification('âœ… è´­ä¹°æˆåŠŸï¼', 'success');
            closeBuyModal();
            
            // æ›´æ–°ä»£å¸çŠ¶æ€
            if (currentBuyToken) {
              currentBuyToken.lastPurchase = {
                amount: buyAmount,
                tokens: parseFloat(ethers.utils.formatUnits(amountOutMin, 18)),
                timestamp: Date.now(),
                txHash: tx.hash
              };
              
              // æ·»åŠ è´­ä¹°å†å²è®°å½•
              addHistoryRecord('purchase', `è´­ä¹°ä»£å¸: ${currentBuyToken.description || 'Unknown Token'}`, currentBuyToken.address, {
                amount: buyAmount,
                tokens: parseFloat(ethers.utils.formatUnits(amountOutMin, 18)),
                txHash: tx.hash,
                description: currentBuyToken.description
              });
              
              // ä¿å­˜åˆ° Firebase
              await saveToFirebase({
                tokens: deployedTokens,
                tokenData: tokenData,
                lastUpdated: Date.now()
              }, 'pumpu_tokens');
            }
          } else {
            showNotification('âŒ è´­ä¹°å¤±è´¥ï¼', 'error');
          }
          
        } catch (error) {
          console.error('è´­ä¹°å¤±è´¥:', error);
          showNotification(`è´­ä¹°å¤±è´¥: ${error.message}`, 'error');
        } finally {
          // æ¢å¤æŒ‰é’®çŠ¶æ€
          confirmBtn.disabled = false;
          confirmBtn.textContent = 'ç¡®è®¤è´­ä¹°';
        }
      }
     
     

                  // æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨
         async function addToMonitoring(address) {
           if (!tokenData[address]) { alert('æœªæ‰¾åˆ°è¯¥ä»£å¸'); return; }
           tokenData[address].isMonitored = true;
           monitoredAddresses.add(address);
           
           // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
           saveMonitoredTokens();
           
           // ä¿å­˜åˆ° Firebase
           await saveToFirebase({
             tokens: deployedTokens,
             tokenData: tokenData,
             monitoredAddresses: Array.from(monitoredAddresses),
             lastUpdated: Date.now()
           }, 'pumpu_tokens');
           
                        // æ·»åŠ ç›‘æ§å†å²è®°å½•
             addHistoryRecord('monitor', `æ·»åŠ åˆ°ç›‘æ§: ${tokenData[address].description || 'Unknown Token'}`, address, {
               description: tokenData[address].description
             });
             
             updateTokenDisplay();
             showNotification('å·²æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨', 'success');
         }

    // é¡¶éƒ¨æ‰‹åŠ¨è·Ÿè¸ªè¾“å…¥
    async function trackAddressFromTopBar() {
      const inp = document.getElementById('trackAddressInput');
      const addr = (inp?.value || '').trim();
      if (!addr || !addr.startsWith('0x') || addr.length < 10) { alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åˆçº¦åœ°å€'); return; }
      try {
        if (!tokenData[addr]) {
          // ä¸çŸ¥é“ amountï¼Œåˆ™ç”¨ 0 ä½œä¸ºå ä½
          await addNewToken(addr, ethers.utils.parseEther('0'));
        }
        await addToMonitoring(addr);
        showColumn('monitoring');
        inp.value = '';
      } catch (e) {
        console.error('æ‰‹åŠ¨è·Ÿè¸ªå¤±è´¥:', e);
        alert('æ·»åŠ å¤±è´¥: ' + (e?.message || e));
      }
    }

    // æ›´æ–°ä»£å¸çŠ¶æ€
    async function updateTokenStatus(address) {
      // è¿™é‡Œå¯ä»¥å®ç°çŠ¶æ€æ›´æ–°é€»è¾‘
      alert('çŠ¶æ€æ›´æ–°åŠŸèƒ½å¼€å‘ä¸­...');
    }

    // æœç´¢ä»£å¸
    function searchTokens(query) {
      if (!query) {
        updateTokenDisplay();
        return;
      }

      const filtered = deployedTokens.filter(token => 
        token.description?.toLowerCase().includes(query.toLowerCase()) ||
        token.address.toLowerCase().includes(query.toLowerCase())
      );

      // æ›´æ–°æ˜¾ç¤º
      updateColumnDisplay('new-tokens', filtered.filter(t => t.status === 'new'));
      updateColumnDisplay('pending-tokens', filtered.filter(t => t.status === 'pending'));
      updateColumnDisplay('opened-tokens', filtered.filter(t => t.status === 'opened'));
    }

         // æ˜¾ç¤ºé¦–é¡µï¼ˆåŒæ—¶æ˜¾ç¤ºä¸‰ä¸ªåˆ—ï¼‰
     function showHome() {
       const sections = ['new', 'pending', 'opened'];
       const idMap = { new: 'new-tokens', pending: 'pending-tokens', opened: 'opened-tokens' };
       sections.forEach(s => {
         const el = document.getElementById(idMap[s]);
         if (el) el.style.display = 'block';
       });
       
       // éšè—ç›‘æ§åˆ—è¡¨å’Œå†å²è®°å½•
       const monitoringEl = document.getElementById('monitoring-tokens');
       const historyEl = document.getElementById('history-tokens');
       if (monitoringEl) monitoringEl.style.display = 'none';
       if (historyEl) historyEl.style.display = 'none';
       
       // æ›´æ–°ç›‘æ§åˆ—è¡¨æ˜¾ç¤ºï¼ˆä½†ä¸æ˜¾ç¤ºï¼‰
       updateMonitoringDisplay();
       
       // é«˜äº®é¦–é¡µèœå•é¡¹
       highlightMenu('home');
     }

         // æ›´æ–°é¢åŒ…å±‘å¯¼èˆª
     function updateBreadcrumb(pageType) {
       const breadcrumb = document.getElementById('current-page');
       if (breadcrumb) {
         if (pageType === 'home') {
           breadcrumb.innerHTML = 'ğŸ  é¦–é¡µ - ç›‘æ§æ¦‚è§ˆ';
         } else if (pageType === 'monitoring') {
           breadcrumb.innerHTML = 'ğŸš€ DYORå‘å°„å°ç›‘æ§ - è¯¦ç»†åˆ—è¡¨';
         } else if (pageType === 'okay-monitoring') {
           breadcrumb.innerHTML = 'ğŸš€ OKAYå‘å°„å°ç›‘æ§ - è¯¦ç»†åˆ—è¡¨';
         } else {
           const title = getColumnTitle(pageType + '-tokens');
           breadcrumb.innerHTML = `ğŸ“Š ${title} - è¯¦ç»†åˆ—è¡¨`;
         }
       }
     }

         // é«˜äº®èœå•é¡¹
     function highlightMenu(activeType) {
       const menuItems = document.querySelectorAll('.menu a');
       menuItems.forEach(item => {
         // ç§»é™¤æ‰€æœ‰é«˜äº®æ ·å¼
         item.style.color = '#fff';
         item.style.fontWeight = 'normal';
         item.style.borderBottom = 'none';
         
         // é«˜äº®å½“å‰é€‰ä¸­çš„èœå•é¡¹
         if (activeType === 'home' && item.textContent.includes('é¦–é¡µ')) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         } else if (activeType === 'monitoring' && item.textContent.includes('DYORå‘å°„å°')) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         } else if (activeType === 'okay-monitoring' && item.textContent.includes('OKAYå‘å°„å°')) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         } else if (item.textContent.includes(getColumnTitle(activeType + '-tokens'))) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         }
       });
       
       // æ›´æ–°é¢åŒ…å±‘å¯¼èˆª
       updateBreadcrumb(activeType);
     }

                   // æ˜¾ç¤ºæŒ‡å®šåˆ—
      function showColumn(type) {
        const sections = ['new', 'pending', 'opened', 'monitoring', 'okay-monitoring', 'history'];
        const idMap = { 
          new: 'new-tokens', 
          pending: 'pending-tokens', 
          opened: 'opened-tokens', 
          monitoring: 'monitoring-tokens',
          'okay-monitoring': 'okay-monitoring-tokens',
          history: 'history-tokens'
        };
        sections.forEach(s => {
          const el = document.getElementById(idMap[s]);
          if (el) el.style.display = (s === type ? 'block' : 'none');
        });
        if (type === 'monitoring') updateMonitoringDisplay();
        if (type === 'okay-monitoring') updateOkayMonitoringDisplay();
        if (type === 'history') updateHistoryDisplay();
        
        // é«˜äº®å¯¹åº”èœå•é¡¹
        highlightMenu(type);
      }

    // åˆ·æ–°å‡½æ•°
    function refreshNewTokens() {
      if (isConnected) {
        loadDeployedTokens();
      }
    }

    function refreshPendingTokens() {
      // åˆ·æ–°å³å°†æ‰“æ»¡çš„ä»£å¸
      console.log('åˆ·æ–°å³å°†æ‰“æ»¡çš„ä»£å¸');
    }

    function refreshOpenedTokens() {
      // åˆ·æ–°å·²å¼€ç›˜çš„ä»£å¸
      console.log('åˆ·æ–°å·²å¼€ç›˜çš„ä»£å¸');
    }

                   function refreshMonitoringTokens() {
        updateMonitoringDisplay();
      }
      
      function refreshOkayMonitoringTokens() {
        updateOkayMonitoringDisplay();
      }
     
     // åˆ·æ–°å†å²è®°å½•
     function refreshHistoryTokens() {
       updateHistoryDisplay();
     }
     
     // æ¸…ç©ºå†å²è®°å½•
     function clearHistory() {
       if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
         historyRecords = [];
         localStorage.removeItem(STORAGE_KEYS.HISTORY_RECORDS);
         saveHistoryToFirebase();
         updateHistoryDisplay();
         showNotification('å†å²è®°å½•å·²æ¸…ç©º', 'success');
       }
     }
     
     // è¿‡æ»¤å†å²è®°å½•
     function filterHistory() {
       updateHistoryDisplay();
     }
     
     // æ›´æ–°å†å²è®°å½•æ˜¾ç¤º
     function updateHistoryDisplay() {
       const column = document.getElementById('history-tokens');
       if (!column) return;
       
       const typeFilter = document.getElementById('historyTypeFilter')?.value || 'all';
       const dateFilter = document.getElementById('historyDateFilter')?.value;
       
       let filteredRecords = [...historyRecords];
       
       // æŒ‰ç±»å‹è¿‡æ»¤
       if (typeFilter !== 'all') {
         filteredRecords = filteredRecords.filter(record => record.type === typeFilter);
       }
       
       // æŒ‰æ—¥æœŸè¿‡æ»¤
       if (dateFilter) {
         const filterDate = new Date(dateFilter);
         filterDate.setHours(0, 0, 0, 0);
         const nextDay = new Date(filterDate);
         nextDay.setDate(nextDay.getDate() + 1);
         
         filteredRecords = filteredRecords.filter(record => {
           const recordDate = new Date(record.timestamp);
           return recordDate >= filterDate && recordDate < nextDay;
         });
       }
       
       if (filteredRecords.length === 0) {
         column.innerHTML = `
           <h2>å†å²è®°å½•
             <button class="refresh-btn" onclick="refreshHistoryTokens()">åˆ·æ–°</button>
             <button class="refresh-btn" onclick="clearHistory()" style="margin-left: 5px; background: #ff4444;">æ¸…ç©º</button>
           </h2>
           <div class="history-filters">
             <select id="historyTypeFilter" onchange="filterHistory()">
               <option value="all">å…¨éƒ¨è®°å½•</option>
               <option value="created">ä»£å¸åˆ›å»º</option>
               <option value="status_change">çŠ¶æ€å˜åŒ–</option>
               <option value="purchase">è´­ä¹°è®°å½•</option>
               <option value="monitor">ç›‘æ§æ“ä½œ</option>
             </select>
             <input type="date" id="historyDateFilter" onchange="filterHistory()" style="margin-left: 10px;">
           </div>
           <div class="loading">æš‚æ— å†å²è®°å½•</div>
         `;
         return;
       }
       
       let html = `
         <h2>å†å²è®°å½•
           <button class="refresh-btn" onclick="refreshHistoryTokens()">åˆ·æ–°</button>
           <button class="refresh-btn" onclick="clearHistory()" style="margin-left: 5px; background: #ff4444;">æ¸…ç©º</button>
         </h2>
         <div class="history-filters">
           <select id="historyTypeFilter" onchange="filterHistory()">
             <option value="all" ${typeFilter === 'all' ? 'selected' : ''}>å…¨éƒ¨è®°å½•</option>
             <option value="created" ${typeFilter === 'created' ? 'selected' : ''}>ä»£å¸åˆ›å»º</option>
             <option value="status_change" ${typeFilter === 'status_change' ? 'selected' : ''}>çŠ¶æ€å˜åŒ–</option>
             <option value="purchase" ${typeFilter === 'purchase' ? 'selected' : ''}>è´­ä¹°è®°å½•</option>
             <option value="monitor" ${typeFilter === 'monitor' ? 'selected' : ''}>ç›‘æ§æ“ä½œ</option>
           </select>
           <input type="date" id="historyDateFilter" onchange="filterHistory()" style="margin-left: 10px;" value="${dateFilter || ''}">
         </div>
       `;
       
       filteredRecords.forEach(record => {
         const recordDate = new Date(record.timestamp);
         const timeAgo = getTimeAgo(record.timestamp);
         
         html += `
           <div class="history-item ${record.type}">
             <div class="time">${timeAgo}</div>
             <div class="type">${getHistoryTypeText(record.type)}</div>
             <div class="content">
               ${record.content}
               ${record.tokenAddress ? `<br><span class="token-address">${record.tokenAddress}</span>` : ''}
               ${record.extraData ? formatExtraData(record.extraData) : ''}
             </div>
           </div>
         `;
       });
       
       column.innerHTML = html;
     }
     
     // è·å–æ—¶é—´å·®æè¿°
     function getTimeAgo(timestamp) {
       const now = Date.now();
       const diff = now - timestamp;
       
       const minutes = Math.floor(diff / 60000);
       const hours = Math.floor(diff / 3600000);
       const days = Math.floor(diff / 86400000);
       
       if (minutes < 1) return 'åˆšåˆš';
       if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`;
       if (hours < 24) return `${hours}å°æ—¶å‰`;
       if (days < 7) return `${days}å¤©å‰`;
       
       return new Date(timestamp).toLocaleDateString();
     }
     
     // è·å–å†å²è®°å½•ç±»å‹æ–‡æœ¬
     function getHistoryTypeText(type) {
       const texts = {
         'created': 'åˆ›å»º',
         'status_change': 'çŠ¶æ€å˜åŒ–',
         'purchase': 'è´­ä¹°',
         'monitor': 'ç›‘æ§'
       };
       return texts[type] || 'æœªçŸ¥';
     }
     
     // æ ¼å¼åŒ–é¢å¤–æ•°æ®
     function formatExtraData(extraData) {
       let result = '';
       if (extraData.amount) result += `<br>é‡‘é¢: ${extraData.amount} OKB`;
       if (extraData.tokens) result += `<br>ä»£å¸: ${extraData.tokens.toFixed(2)}`;
       if (extraData.txHash) result += `<br>äº¤æ˜“: ${extraData.txHash.substring(0, 10)}...`;
       if (extraData.oldStatus && extraData.newStatus) {
         result += `<br>çŠ¶æ€: ${getStatusText(extraData.oldStatus)} â†’ ${getStatusText(extraData.newStatus)}`;
       }
       return result;
     }

    // å¯åŠ¨çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
    function startStatusUpdates() {
      // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡ä»£å¸çŠ¶æ€
      statusUpdateInterval = setInterval(() => {
        deployedTokens.forEach(token => {
          if (token.status !== 'opened') {
            checkTokenStatus(token.address);
          }
        });
      }, OPENING_DETECTION_CONFIG.STATUS_CHECK_INTERVAL);

      // æ¯10ç§’æ›´æ–°ä¸€æ¬¡ä»·æ ¼
      priceUpdateInterval = setInterval(() => {
        deployedTokens.forEach(token => {
          if (token.status === 'opened') {
            updateTokenPrice(token.address);
          }
        });
      }, OPENING_DETECTION_CONFIG.PRICE_MONITORING.UPDATE_INTERVAL);
    }

    // æ£€æŸ¥ä»£å¸çŠ¶æ€
    async function checkTokenStatus(address) {
      try {
        const token = tokenData[address];
        if (!token) return;

        // æ£€æŸ¥æ˜¯å¦æ»¡è¶³å¼€ç›˜æ¡ä»¶
        const isOpened = await checkOpeningConditions(address);
        
        if (isOpened && token.status !== 'opened') {
                     token.status = 'opened';
           token.lastStatusUpdate = Date.now();
           console.log(`ä»£å¸ ${token.description || address} å·²å¼€ç›˜ï¼`);
           
           // æ·»åŠ å†å²è®°å½•
           addHistoryRecord('status_change', `ä»£å¸å¼€ç›˜: ${token.description || 'Unknown Token'}`, address, {
             oldStatus: 'pending',
             newStatus: 'opened',
             description: token.description
           });
           
           // æ›´æ–°UI
           updateTokenDisplay();
           
           // ä¿å­˜åˆ° Firebase
           await saveToFirebase({
             tokens: deployedTokens,
             tokenData: tokenData,
             lastUpdated: Date.now()
           }, 'pumpu_tokens');
           
           // æ˜¾ç¤ºå¼€ç›˜é€šçŸ¥
           showOpeningNotification(token);
        } else if (!isOpened && token.status === 'new') {
          // æ£€æŸ¥æ˜¯å¦å³å°†æ‰“æ»¡
          const isPending = await checkPendingConditions(address);
                     if (isPending) {
             token.status = 'pending';
             token.lastStatusUpdate = Date.now();
             
             // æ·»åŠ å†å²è®°å½•
             addHistoryRecord('status_change', `ä»£å¸å³å°†æ‰“æ»¡: ${token.description || 'Unknown Token'}`, address, {
               oldStatus: 'new',
               newStatus: 'pending',
               description: token.description
             });
             
             updateTokenDisplay();
             
             // ä¿å­˜åˆ° Firebase
             await saveToFirebase({
               tokens: deployedTokens,
               tokenData: tokenData,
               lastUpdated: Date.now()
             }, 'pumpu_tokens');
           }
        }
      } catch (error) {
        console.error(`æ£€æŸ¥ä»£å¸çŠ¶æ€å¤±è´¥ ${address}:`, error);
      }
    }

    // æ£€æŸ¥å¼€ç›˜æ¡ä»¶
    async function checkOpeningConditions(address) {
      try {
        const conditions = OPENING_DETECTION_CONFIG.OPENING_CONDITIONS;

        // ä¼˜å…ˆå°è¯•æŒ‰ UniswapV2 Pair è¯»å–å‚¨å¤‡ï¼ˆPumpu ä¸‹åœ°å€å³ä¸ºæ± å­åœ°å€ï¼‰
        let liquidityOkb = 0;
        let priceOkb = 0;
        try {
          const pair = new ethers.Contract(address, PAIR_ABI, readProvider);
          const [reserve0, reserve1] = await pair.getReserves();
          const [t0, t1] = await Promise.all([
            pair.token0(),
            pair.token1()
          ]);
          const wokbLower = CONFIG.WOKB.toLowerCase();
          if (t0.toLowerCase() === wokbLower) {
            liquidityOkb = Number(ethers.utils.formatEther(reserve0));
            if (reserve1.gt(0)) {
              priceOkb = Number(ethers.utils.formatEther(reserve0)) / Number(ethers.utils.formatEther(reserve1));
            }
          } else if (t1.toLowerCase() === wokbLower) {
            liquidityOkb = Number(ethers.utils.formatEther(reserve1));
            if (reserve0.gt(0)) {
              priceOkb = Number(ethers.utils.formatEther(reserve1)) / Number(ethers.utils.formatEther(reserve0));
            }
          }
        } catch (_) {
                     // ä¸å±äºæ ‡å‡† Pairï¼Œåˆ™å°è¯• Pumpu è™šæ‹Ÿ/çœŸå®å‚¨å¤‡
           try {
             const pump = new ethers.Contract(address, PUMP_TOKEN_EXT_ABI, readProvider);
             const [vEth, vTok, rEth, rTok] = await Promise.all([
               pump.virtualEth().catch(() => ethers.constants.Zero),
               pump.virtualToken().catch(() => ethers.constants.Zero),
               pump.realEth().catch(() => ethers.constants.Zero),
               pump.realToken().catch(() => ethers.constants.Zero)
             ]);
             
             // è™šæ‹Ÿå‚¨å¤‡ + çœŸå®å‚¨å¤‡ = æ€»å‚¨å¤‡
             const totalEth = vEth.add(rEth);
             liquidityOkb = Number(ethers.utils.formatEther(totalEth));
             
             if (vTok.gt(0) || rTok.gt(0)) {
               const totalTok = vTok.add(rTok);
               priceOkb = Number(ethers.utils.formatEther(totalEth)) / Number(ethers.utils.formatEther(totalTok));
             }
           } catch (__) {}
        }

        tokenData[address].liquidity = liquidityOkb;
        tokenData[address].price = priceOkb;
        
        // è·å–ä»£å¸æ€»ä¾›åº”é‡å’Œè®¡ç®—å¸‚å€¼
        try {
          const tokenContract = new ethers.Contract(address, ERC20_METADATA_ABI, readProvider);
          const [supply, decimals] = await Promise.all([
            tokenContract.totalSupply(),
            tokenContract.decimals()
          ]);
          
          const totalSupply = parseFloat(ethers.utils.formatUnits(supply, decimals));
          tokenData[address].totalSupply = totalSupply;
          
          // è®¡ç®—å¸‚å€¼ï¼šæ€»ä¾›åº”é‡ Ã— ä»·æ ¼
          if (priceOkb > 0 && totalSupply > 0) {
            tokenData[address].marketCap = totalSupply * priceOkb;
          } else {
            tokenData[address].marketCap = 0;
          }
        } catch (capError) {
          console.warn('æ— æ³•è·å–å¸‚å€¼ä¿¡æ¯:', capError);
          tokenData[address].totalSupply = 0;
          tokenData[address].marketCap = 0;
        }
        
        // æ—  indexer æƒ…å†µä¸‹ï¼ŒholderCount ä¸ tradeVolume æš‚ç½® 0
        tokenData[address].holderCount = 0;
        tokenData[address].tradeVolume = 0;

        return (
          liquidityOkb >= conditions.MIN_LIQUIDITY_OKB &&
          0 >= conditions.MIN_TRADE_VOLUME &&
          0 >= conditions.MIN_HOLDER_COUNT
        );
      } catch (error) {
        console.error(`æ£€æŸ¥å¼€ç›˜æ¡ä»¶å¤±è´¥ ${address}:`, error);
        return false;
      }
    }

    // æ£€æŸ¥å³å°†æ‰“æ»¡æ¡ä»¶
    async function checkPendingConditions(address) {
      try {
        const token = tokenData[address];
        
        // æ£€æŸ¥æµåŠ¨æ€§æ˜¯å¦æ¥è¿‘å¼€ç›˜æ¡ä»¶ï¼ˆæ¯”å¦‚è¾¾åˆ°80%ä»¥ä¸Šï¼‰
        const conditions = OPENING_DETECTION_CONFIG.OPENING_CONDITIONS;
        const minLiquidity = conditions.MIN_LIQUIDITY_OKB;
        
        // è·å–å½“å‰æµåŠ¨æ€§
        let currentLiquidity = 0;
        try {
          // ä¼˜å…ˆå°è¯•æŒ‰ UniswapV2 Pair è¯»å–å‚¨å¤‡
          const pair = new ethers.Contract(address, PAIR_ABI, readProvider);
          const [reserve0, reserve1] = await pair.getReserves();
          const [t0, t1] = await Promise.all([
            pair.token0(),
            pair.token1()
          ]);
          const wokbLower = CONFIG.WOKB.toLowerCase();
          if (t0.toLowerCase() === wokbLower) {
            currentLiquidity = Number(ethers.utils.formatEther(reserve0));
          } else if (t1.toLowerCase() === wokbLower) {
            currentLiquidity = Number(ethers.utils.formatEther(reserve1));
          }
        } catch (_) {
          // å°è¯• Pumpu è™šæ‹Ÿå‚¨å¤‡
          try {
            const pump = new ethers.Contract(address, PUMP_TOKEN_EXT_ABI, readProvider);
            const [vEth, vTok, rEth, rTok] = await Promise.all([
              pump.virtualEth().catch(() => ethers.constants.Zero),
              pump.virtualToken().catch(() => ethers.constants.Zero),
              pump.realEth().catch(() => ethers.constants.Zero),
              pump.realToken().catch(() => ethers.constants.Zero)
            ]);
            
            const totalEth = vEth.add(rEth);
            currentLiquidity = Number(ethers.utils.formatEther(totalEth));
          } catch (__) {}
        }
        
        // å¦‚æœæµåŠ¨æ€§è¾¾åˆ°å¼€ç›˜æ¡ä»¶çš„80%ä»¥ä¸Šï¼Œæ ‡è®°ä¸ºå³å°†æ‰“æ»¡
        const liquidityThreshold = minLiquidity * 0.8; // 80%çš„å¼€ç›˜æ¡ä»¶
        return currentLiquidity >= liquidityThreshold && currentLiquidity < minLiquidity;
        
      } catch (error) {
        console.error(`æ£€æŸ¥å³å°†æ‰“æ»¡æ¡ä»¶å¤±è´¥ ${address}:`, error);
        return false;
      }
    }

    // æ›´æ–°ä»£å¸ä»·æ ¼
    async function updateTokenPrice(address) {
      try {
        const token = tokenData[address];
        if (!token) return;
        let priceOkb = token.price || 0;
        // å†æ¬¡æŒ‰å‚¨å¤‡è®¡ç®—ä»·æ ¼
        try {
          const pair = new ethers.Contract(address, PAIR_ABI, readProvider);
          const [reserve0, reserve1] = await pair.getReserves();
          const [t0, t1] = await Promise.all([pair.token0(), pair.token1()]);
          const wokbLower = CONFIG.WOKB.toLowerCase();
          if (t0.toLowerCase() === wokbLower && reserve1.gt(0)) {
            priceOkb = Number(ethers.utils.formatEther(reserve0)) / Number(ethers.utils.formatEther(reserve1));
          } else if (t1.toLowerCase() === wokbLower && reserve0.gt(0)) {
            priceOkb = Number(ethers.utils.formatEther(reserve1)) / Number(ethers.utils.formatEther(reserve0));
          }
                 } catch (_) {
           try {
             const pump = new ethers.Contract(address, PUMP_TOKEN_EXT_ABI, readProvider);
             const [vEth, vTok, rEth, rTok] = await Promise.all([
               pump.virtualEth().catch(() => ethers.constants.Zero),
               pump.virtualToken().catch(() => ethers.constants.Zero),
               pump.realEth().catch(() => ethers.constants.Zero),
               pump.realToken().catch(() => ethers.constants.Zero)
             ]);
             
             if (vTok.gt(0) || rTok.gt(0)) {
               const totalEth = vEth.add(rEth);
               const totalTok = vTok.add(rTok);
               priceOkb = Number(ethers.utils.formatEther(totalEth)) / Number(ethers.utils.formatEther(totalTok));
             }
           } catch (__) {}
         }
        token.price = priceOkb;
        
        // æ›´æ–°å¸‚å€¼
        if (token.totalSupply && token.totalSupply > 0 && priceOkb > 0) {
          token.marketCap = token.totalSupply * priceOkb;
        }
        
        updateTokenPriceDisplay(address);
      } catch (error) {
        console.error(`æ›´æ–°ä»£å¸ä»·æ ¼å¤±è´¥ ${address}:`, error);
      }
    }

    // æ›´æ–°ä»£å¸ä»·æ ¼æ˜¾ç¤º
    function updateTokenPriceDisplay(address) {
      // ç®€åŒ–ï¼šé‡æ–°æ¸²æŸ“å¡ç‰‡åŒºåŸŸaa
      updateTokenDisplay();
    }

    // æ˜¾ç¤ºå¼€ç›˜é€šçŸ¥
    function showOpeningNotification(token) {
      // åˆ›å»ºå¼€ç›˜é€šçŸ¥
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #00ff00;
        color: #000;
        padding: 15px;
        border-radius: 8px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,255,0,0.3);
        animation: slideIn 0.5s ease;
      `;
      
      notification.innerHTML = `
        <h4>ğŸš€ ä»£å¸å·²å¼€ç›˜ï¼</h4>
        <p><strong>${token.description || 'Unknown Token'}</strong></p>
        <p>åœ°å€: ${token.address.substring(0, 8)}...${token.address.substring(36)}</p>
        <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 10px;">å…³é—­</button>
      `;
      
      document.body.appendChild(notification);
      
      // 5ç§’åè‡ªåŠ¨æ¶ˆå¤±
      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, 5000);
    }

            // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);

        // é¡µé¢å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨
        window.addEventListener('beforeunload', () => {
          if (statusUpdateInterval) clearInterval(statusUpdateInterval);
          if (priceUpdateInterval) clearInterval(priceUpdateInterval);
        });

                         // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
         window.onclick = function(event) {
           const tokenModal = document.getElementById('tokenModal');
           const buyModal = document.getElementById('buyModal');
           
           if (event.target === tokenModal) {
             tokenModal.style.display = 'none';
           }
           
           if (event.target === buyModal) {
             closeBuyModal();
           }
         }

                 // æ·»åŠ CSSåŠ¨ç”»
         const style = document.createElement('style');
         style.textContent = `
           @keyframes slideIn {
             from { transform: translateX(100%); opacity: 0; }
             to { transform: translateX(0); opacity: 1; }
           }
           
           @keyframes fadeIn {
             from { opacity: 0; }
             to { opacity: 1; }
           }
           
           .notification {
             position: fixed;
             top: 20px;
             right: 20px;
             padding: 15px 20px;
             border-radius: 8px;
             color: #fff;
             font-weight: bold;
             z-index: 10000;
             animation: slideIn 0.5s ease;
             max-width: 300px;
           }
           
           .notification.success {
             background: #00ff00;
             color: #000;
           }
           
           .notification.warning {
             background: #ffaa00;
             color: #000;
           }
           
           .notification.error {
             background: #ff4444;
           }
           
           .notification.info {
             background: #00d8ff;
             color: #000;
           }
           
           .settings-panel {
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background: #1e1e1e;
             padding: 20px;
             border-radius: 8px;
             border: 1px solid #2c2c2c;
             z-index: 10001;
             display: none;
             min-width: 400px;
           }
           
           .settings-panel h3 {
             margin-bottom: 20px;
             color: #00d8ff;
           }
           
           .setting-item {
             margin-bottom: 15px;
             display: flex;
             justify-content: space-between;
             align-items: center;
           }
           
           .setting-item label {
             color: #fff;
           }
           
           .setting-item input[type="checkbox"] {
             width: 20px;
             height: 20px;
           }
           
                .setting-item input[type="number"] {
       width: 80px;
       padding: 5px;
       background: #2c2c2c;
       border: 1px solid #444;
       color: #fff;
       border-radius: 4px;
     }
     
           /* è´­ä¹°ç•Œé¢æ ·å¼ */
      .buy-interface {
        padding: 25px 0;
      }
      
      .buy-input-group {
        margin-bottom: 25px;
      }
     
     .buy-input-group label {
       display: block;
       margin-bottom: 8px;
       color: #00d8ff;
       font-weight: bold;
     }
     
     .buy-input-group input {
       width: 100%;
       padding: 12px;
       background: #2c2c2c;
       border: 1px solid #444;
       color: #fff;
       border-radius: 6px;
       font-size: 16px;
     }
     
     .buy-input-group input:focus {
       outline: none;
       border-color: #00d8ff;
       box-shadow: 0 0 0 2px rgba(0, 216, 255, 0.2);
     }
     
     .buy-preview {
       background: #2c2c2c;
       padding: 15px;
       border-radius: 6px;
       margin-bottom: 20px;
       border-left: 4px solid #00d8ff;
     }
     
     .buy-preview h4 {
       color: #00d8ff;
       margin-bottom: 10px;
     }
     
     .buy-preview p {
       margin: 5px 0;
       color: #ccc;
     }
     
     .buy-actions {
       display: flex;
       gap: 10px;
       justify-content: center;
     }
     
     .buy-confirm-btn {
       background: #00ff00;
       color: #000;
       padding: 12px 24px;
       border: none;
       border-radius: 6px;
       font-size: 16px;
       font-weight: bold;
       cursor: pointer;
       transition: all 0.3s ease;
     }
     
     .buy-confirm-btn:hover {
       background: #00cc00;
       transform: translateY(-2px);
     }
     
     .buy-confirm-btn:disabled {
       background: #666;
       cursor: not-allowed;
       transform: none;
     }
     
     .slippage-input {
       width: 80px !important;
       text-align: center;
     }
     
     /* å†å²è®°å½•æ ·å¼ */
     .history-filters {
       margin-bottom: 15px;
       padding: 10px;
       background: #2c2c2c;
       border-radius: 6px;
       display: flex;
       align-items: center;
       gap: 10px;
     }
     
     .history-filters select,
     .history-filters input {
       background: #1e1e1e;
       border: 1px solid #444;
       color: #fff;
       padding: 5px 8px;
       border-radius: 4px;
       font-size: 12px;
     }
     
     .history-item {
       background: #2c2c2c;
       border-radius: 6px;
       padding: 12px;
       margin-bottom: 10px;
       border-left: 4px solid #00d8ff;
       position: relative;
     }
     
     .history-item.created { border-left-color: #00ff00; }
     .history-item.status_change { border-left-color: #ffaa00; }
     .history-item.purchase { border-left-color: #00d8ff; }
     .history-item.monitor { border-left-color: #ff00ff; }
     
     .history-item .time {
       position: absolute;
       top: 8px;
       right: 12px;
       font-size: 11px;
       color: #888;
     }
     
     .history-item .type {
       display: inline-block;
       padding: 2px 6px;
       border-radius: 3px;
       font-size: 10px;
       font-weight: bold;
       margin-bottom: 5px;
     }
     
     .history-item.created .type { background: #00ff00; color: #000; }
     .history-item.status_change .type { background: #ffaa00; color: #000; }
     .history-item.purchase .type { background: #00d8ff; color: #000; }
     .history-item.monitor .type { background: #ff00ff; color: #000; }
     
     .history-item .content {
       color: #ccc;
       font-size: 13px;
       line-height: 1.4;
     }
     
     .history-item .token-address {
       font-family: monospace;
       background: #1e1e1e;
       padding: 2px 4px;
       border-radius: 3px;
       font-size: 11px;
     }
         `;
         document.head.appendChild(style);
         
         // Firebase æ•°æ®å­˜å‚¨å’Œè¯»å–åŠŸèƒ½
         async function saveToFirebase(data, path) {
           try {
             await database.ref(path).set(data);
             console.log(`âœ… æ•°æ®å·²ä¿å­˜åˆ° Firebase: ${path}`);
           } catch (error) {
             console.error(`âŒ ä¿å­˜åˆ° Firebase å¤±è´¥: ${path}`, error);
           }
         }

         async function loadFromFirebase(path) {
           try {
             const snapshot = await database.ref(path).once('value');
             const data = snapshot.val();
             console.log(`âœ… ä» Firebase åŠ è½½æ•°æ®: ${path}`, data);
             return data;
           } catch (error) {
             console.error(`âŒ ä» Firebase åŠ è½½å¤±è´¥: ${path}`, error);
             return null;
           }
         }

                   // æœ¬åœ°å­˜å‚¨åŠŸèƒ½ï¼ˆä½œä¸ºå¤‡ç”¨ï¼‰
                     function loadLocalData() {
             try {
               // åŠ è½½ç›‘æ§çš„ä»£å¸
               const savedMonitored = localStorage.getItem(STORAGE_KEYS.MONITORED_TOKENS);
               if (savedMonitored) {
                 const addresses = JSON.parse(savedMonitored);
                 monitoredAddresses = new Set(addresses);
                 console.log('å·²åŠ è½½æœ¬åœ°ç›‘æ§ä»£å¸:', addresses.length, 'ä¸ª');
               }
               
               // åŠ è½½OKAYç›‘æ§çš„ä»£å¸
               const savedOkayMonitored = localStorage.getItem(STORAGE_KEYS.OKAY_MONITORED_TOKENS);
               if (savedOkayMonitored) {
                 const addresses = JSON.parse(savedOkayMonitored);
                 okayMonitoredAddresses = new Set(addresses);
                 console.log('å·²åŠ è½½æœ¬åœ°OKAYç›‘æ§ä»£å¸:', addresses.length, 'ä¸ª');
               }
               
               // åŠ è½½ç”¨æˆ·åå¥½
               const savedPrefs = localStorage.getItem(STORAGE_KEYS.USER_PREFERENCES);
               if (savedPrefs) {
                 userPreferences = { ...userPreferences, ...JSON.parse(savedPrefs) };
                 console.log('å·²åŠ è½½æœ¬åœ°ç”¨æˆ·åå¥½è®¾ç½®');
               }
               
               // åŠ è½½å†å²è®°å½•
               const savedHistory = localStorage.getItem(STORAGE_KEYS.HISTORY_RECORDS);
               if (savedHistory) {
                 historyRecords = JSON.parse(savedHistory);
                 console.log('å·²åŠ è½½æœ¬åœ°å†å²è®°å½•:', historyRecords.length, 'æ¡');
               }
             } catch (error) {
               console.error('åŠ è½½æœ¬åœ°æ•°æ®å¤±è´¥:', error);
             }
           }
         
         function saveMonitoredTokens() {
           try {
             localStorage.setItem(STORAGE_KEYS.MONITORED_TOKENS, JSON.stringify([...monitoredAddresses]));
           } catch (error) {
             console.error('ä¿å­˜ç›‘æ§ä»£å¸å¤±è´¥:', error);
           }
         }
         
         function saveOkayMonitoredTokens() {
           try {
             localStorage.setItem(STORAGE_KEYS.OKAY_MONITORED_TOKENS, JSON.stringify([...okayMonitoredAddresses]));
           } catch (error) {
             console.error('ä¿å­˜OKAYç›‘æ§ä»£å¸å¤±è´¥:', error);
           }
         }
         
         function saveUserPreferences() {
           try {
             localStorage.setItem(STORAGE_KEYS.USER_PREFERENCES, JSON.stringify(userPreferences));
           } catch (error) {
             console.error('ä¿å­˜ç”¨æˆ·åå¥½å¤±è´¥:', error);
           }
         }
         
         function saveTokenHistory() {
           try {
             const history = {
               tokens: deployedTokens,
               tokenData: tokenData,
               timestamp: Date.now()
             };
             localStorage.setItem(STORAGE_KEYS.TOKEN_HISTORY, JSON.stringify(history));
           } catch (error) {
             console.error('ä¿å­˜ä»£å¸å†å²å¤±è´¥:', error);
           }
         }
         
                   // æ·»åŠ å†å²è®°å½•
          function addHistoryRecord(type, content, tokenAddress = null, extraData = {}) {
            const record = {
              id: Date.now() + Math.random(),
              type: type,
              content: content,
              tokenAddress: tokenAddress,
              timestamp: Date.now(),
              ...extraData
            };
            
            historyRecords.unshift(record); // æ·»åŠ åˆ°å¼€å¤´
            
            // é™åˆ¶å†å²è®°å½•æ•°é‡ï¼ˆæœ€å¤š1000æ¡ï¼‰
            if (historyRecords.length > 1000) {
              historyRecords = historyRecords.slice(0, 1000);
            }
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            try {
              localStorage.setItem(STORAGE_KEYS.HISTORY_RECORDS, JSON.stringify(historyRecords));
            } catch (error) {
              console.error('ä¿å­˜å†å²è®°å½•å¤±è´¥:', error);
            }
            
            // ä¿å­˜åˆ° Firebase
            saveHistoryToFirebase();
            
            console.log('ğŸ“š æ·»åŠ å†å²è®°å½•:', record);
          }
          
          // ä¿å­˜å†å²è®°å½•åˆ° Firebase
          async function saveHistoryToFirebase() {
            try {
              await saveToFirebase({
                historyRecords: historyRecords,
                lastUpdated: Date.now()
              }, 'pumpu_history');
            } catch (error) {
              console.error('ä¿å­˜å†å²è®°å½•åˆ° Firebase å¤±è´¥:', error);
            }
          }
          
          // åŠ è½½å†å²è®°å½•
          async function loadHistoryRecords() {
            try {
              const firebaseHistory = await loadFromFirebase('pumpu_history');
              if (firebaseHistory && firebaseHistory.historyRecords) {
                historyRecords = firebaseHistory.historyRecords;
                console.log(`âœ… ä» Firebase åŠ è½½äº† ${historyRecords.length} æ¡å†å²è®°å½•`);
              }
            } catch (error) {
              console.error('åŠ è½½å†å²è®°å½•å¤±è´¥:', error);
            }
          }
          
                 // OKAYç›‘æ§ç›¸å…³å‡½æ•°
       async function addOkayToken() {
         const address = prompt('è¯·è¾“å…¥ä»£å¸åˆçº¦åœ°å€:');
         if (!address || !address.startsWith('0x')) {
           alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åˆçº¦åœ°å€');
           return;
         }
         
         try {
           // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨ç›‘æ§ä¸­
           if (okayMonitoredAddresses.has(address)) {
             alert('è¯¥ä»£å¸å·²åœ¨OKAYç›‘æ§åˆ—è¡¨ä¸­');
             return;
           }
           
           // ä»Tokenåˆçº¦è·å–ä»£å¸ä¿¡æ¯
           const tokenInfo = await getTokenInfoFromContract(address);
           if (tokenInfo) {
             // æ·»åŠ åˆ°OKAYç›‘æ§åˆ—è¡¨
             okayMonitoredAddresses.add(address);
             
             // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
             saveOkayMonitoredTokens();
             
             // ä¿å­˜åˆ°Firebase
             await saveToFirebase({
               okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // æ›´æ–°æ˜¾ç¤º
             updateOkayMonitoringDisplay();
             
             // æ·»åŠ å†å²è®°å½•
             addHistoryRecord('monitor', `æ·»åŠ åˆ°OKAYç›‘æ§: ${tokenInfo.name || 'Unknown Token'}`, address, {
               description: tokenInfo.name,
               symbol: tokenInfo.symbol,
               image: tokenInfo.image
             });
             
             showNotification(`å·²æ·»åŠ åˆ°OKAYç›‘æ§: ${tokenInfo.name}`, 'success');
           }
         } catch (error) {
           console.error('æ·»åŠ OKAYç›‘æ§ä»£å¸å¤±è´¥:', error);
           alert('æ·»åŠ å¤±è´¥: ' + error.message);
         }
       }
       
       // ä»Tokenåˆçº¦è·å–ä»£å¸ä¿¡æ¯
       async function getTokenInfoFromContract(address) {
         try {
           // Tokenåˆçº¦ABIï¼ŒåŒ…å«uri()å‡½æ•°
           const TOKEN_ABI = [
             "function uri() external view returns (string calldata)"
           ];
           
           const tokenContract = new ethers.Contract(address, TOKEN_ABI, readProvider);
           
           // è°ƒç”¨uri()å‡½æ•°è·å–IPFS URL
           const uri = await tokenContract.uri();
           console.log('è·å–åˆ°Token URI:', uri);
           
           if (!uri || uri === '') {
             throw new Error('Token URIä¸ºç©º');
           }
           
           // è§£æIPFS URL
           let ipfsUrl = uri;
           if (uri.startsWith('ipfs://')) {
             // å°è¯•å¤šä¸ªIPFSç½‘å…³
             const ipfsGateways = [
               'https://newgame.mypinata.cloud/ipfs/',
               'https://ipfs.io/ipfs/',
               'https://gateway.pinata.cloud/ipfs/',
               'https://cloudflare-ipfs.com/ipfs/'
             ];
             
             // å°è¯•ç¬¬ä¸€ä¸ªç½‘å…³
             ipfsUrl = uri.replace('ipfs://', ipfsGateways[0]);
           } else if (uri.startsWith('http')) {
             ipfsUrl = uri;
           } else {
             throw new Error('ä¸æ”¯æŒçš„URIæ ¼å¼: ' + uri);
           }
           
           // HTTP GETè¯·æ±‚è·å–ä»£å¸ä¿¡æ¯
           let response = await fetch(ipfsUrl);
           
           // å¦‚æœæ˜¯IPFSä¸”ç¬¬ä¸€ä¸ªç½‘å…³å¤±è´¥ï¼Œå°è¯•å…¶ä»–ç½‘å…³
           if (uri.startsWith('ipfs://') && !response.ok) {
             for (let i = 1; i < ipfsGateways.length; i++) {
               try {
                 const backupUrl = uri.replace('ipfs://', ipfsGateways[i]);
                 console.log(`å°è¯•å¤‡ç”¨IPFSç½‘å…³: ${backupUrl}`);
                 response = await fetch(backupUrl);
                 if (response.ok) {
                   ipfsUrl = backupUrl;
                   break;
                 }
               } catch (e) {
                 console.log(`ç½‘å…³ ${ipfsGateways[i]} å¤±è´¥:`, e);
                 continue;
               }
             }
           }
           
           if (!response.ok) {
             throw new Error(`æ‰€æœ‰IPFSç½‘å…³éƒ½å¤±è´¥ï¼Œæœ€åå°è¯•: ${response.status}`);
           }
           
           const tokenData = await response.json();
           console.log('è·å–åˆ°ä»£å¸ä¿¡æ¯:', tokenData);
           
           // å®½æ¾æ ¡éªŒä¸å­—æ®µå…œåº•
           const metaName = (tokenData && tokenData.name) ? String(tokenData.name) : '';
           const metaSymbol = (tokenData && tokenData.symbol) ? String(tokenData.symbol) : '';
           
           // è§„èŒƒåŒ–å›¾ç‰‡URLï¼ˆå¤„ç† ipfs:// ä¸ /ipfs/ å‰ç¼€ï¼‰
           let resolvedImage = tokenData.image || '';
           try {
             if (resolvedImage) {
               const gatewayBase = (ipfsUrl && ipfsUrl.startsWith('http') && ipfsUrl.includes('/ipfs/'))
                 ? (ipfsUrl.split('/ipfs/')[0] + '/ipfs/')
                 : 'https://ipfs.io/ipfs/';

               if (typeof resolvedImage === 'string') {
                 if (resolvedImage.startsWith('ipfs://ipfs/')) {
                   const cidPart = resolvedImage.replace('ipfs://ipfs/', '');
                   resolvedImage = gatewayBase + cidPart;
                 } else if (resolvedImage.startsWith('ipfs://')) {
                   const cidPart = resolvedImage.replace('ipfs://', '');
                   resolvedImage = gatewayBase + cidPart;
                 } else if (resolvedImage.startsWith('/ipfs/')) {
                   const cidPart = resolvedImage.replace('/ipfs/', '');
                   resolvedImage = gatewayBase + cidPart;
                 }
               }
             }
           } catch (normalizeErr) {
             console.warn('å›¾ç‰‡URLè§„èŒƒåŒ–å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹imageå­—æ®µ:', normalizeErr);
           }

           // åˆ›å»ºä»£å¸ä¿¡æ¯å¯¹è±¡
           const tokenInfo = {
             address: address,
             name: metaName,
             symbol: metaSymbol,
             image: resolvedImage,
             twitter: tokenData.twitter || '',
             telegram: tokenData.telegram || '',
             website: tokenData.website || '',
             timestamp: Date.now(),
             source: 'okay-monitoring'
           };
           
           // å¦‚æœä»£å¸ä¸åœ¨deployedTokensä¸­ï¼Œæ·»åŠ å®ƒ
           if (!window.tokenData[address]) {
             window.tokenData[address] = tokenInfo;
             window.deployedTokens.push(tokenInfo);
           }
           
           return tokenInfo;
         } catch (error) {
           console.error('è·å–ä»£å¸ä¿¡æ¯å¤±è´¥:', error);
           throw new Error('æ— æ³•è·å–ä»£å¸ä¿¡æ¯: ' + error.message);
         }
       }
       
       // æµ‹è¯•æŒ‡å®šçš„ä»£å¸åˆçº¦
       async function testSpecificToken() {
         const testAddress = '0xfd09526b00afa829c0f855d02eff47cd2a009595';
         console.log('å¼€å§‹æµ‹è¯•æŒ‡å®šä»£å¸:', testAddress);
         
         try {
           // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨ç›‘æ§ä¸­
           if (okayMonitoredAddresses.has(testAddress)) {
             alert('è¯¥ä»£å¸å·²åœ¨OKAYç›‘æ§åˆ—è¡¨ä¸­');
             return;
           }
           
           console.log('æ­£åœ¨è·å–ä»£å¸ä¿¡æ¯...');
           // ä»Tokenåˆçº¦è·å–ä»£å¸ä¿¡æ¯
           const tokenInfo = await getTokenInfoFromContract(testAddress);
           console.log('è·å–åˆ°çš„ä»£å¸ä¿¡æ¯:', tokenInfo);
           
           if (tokenInfo) {
             // æ·»åŠ åˆ°OKAYç›‘æ§åˆ—è¡¨
             okayMonitoredAddresses.add(testAddress);
             
             // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
             saveOkayMonitoredTokens();
             
             // ä¿å­˜åˆ°Firebase
             await saveToFirebase({
               okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // æ›´æ–°æ˜¾ç¤º
             updateOkayMonitoringDisplay();
             
             // æ·»åŠ å†å²è®°å½•
             addHistoryRecord('monitor', `æµ‹è¯•æ·»åŠ OKAYç›‘æ§: ${tokenInfo.name || 'Unknown Token'}`, testAddress, {
               description: tokenInfo.name,
               symbol: tokenInfo.symbol,
               image: tokenInfo.image
             });
             
             showNotification(`æµ‹è¯•æˆåŠŸï¼å·²æ·»åŠ åˆ°OKAYç›‘æ§: ${tokenInfo.name}`, 'success');
             
             // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
             alert(`æµ‹è¯•æˆåŠŸï¼\n\nä»£å¸åç§°: ${tokenInfo.name}\nä»£å¸ç¬¦å·: ${tokenInfo.symbol}\nåˆçº¦åœ°å€: ${testAddress}\n\nè¯¥ä»£å¸å·²æˆåŠŸæ·»åŠ åˆ°OKAYç›‘æ§åˆ—è¡¨ï¼`);
           }
         } catch (error) {
           console.error('æµ‹è¯•æŒ‡å®šä»£å¸å¤±è´¥:', error);
           alert('æµ‹è¯•å¤±è´¥: ' + error.message + '\n\nè¯·æ£€æŸ¥æ§åˆ¶å°è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯ã€‚');
         }
       }
       
       // è·å–DYORå‘å°„å°ä»£å¸çš„å®æ—¶ä»·æ ¼å’ŒæµåŠ¨æ€§ä¿¡æ¯
       async function getDYORTokenPriceAndLiquidity(tokenAddress) {
         try {
           if (!readProvider) {
             throw new Error('åªè¯»Provideræœªåˆå§‹åŒ–');
           }
           
           // åˆ›å»ºRouteråˆçº¦å®ä¾‹
           const routerContract = new ethers.Contract(CONFIG.PUMPU_ROUTER, CONFIG.ROUTER_ABI, readProvider);
           
           // è·å–ä»£å¸å¯¹åœ°å€ï¼ˆè¿™é‡Œå‡è®¾æ˜¯WOKB/Tokenå¯¹ï¼‰
           const wokbAddress = CONFIG.WOKB;
           const tokenAddress = tokenAddress;
           
           // è®¡ç®—ä»·æ ¼ï¼š1 OKBèƒ½ä¹°å¤šå°‘ä»£å¸
           const amountIn = ethers.utils.parseEther('1'); // 1 OKB
           const path = [wokbAddress, tokenAddress];
           
           try {
             const amounts = await routerContract.getAmountsOut(amountIn, path);
             const tokenAmount = amounts[1];
             const price = parseFloat(ethers.utils.formatUnits(tokenAmount, 18));
             
             // è®¡ç®—æµåŠ¨æ€§ï¼ˆé€šè¿‡Pairåˆçº¦è·å–ï¼‰
             let liquidity = 0;
             try {
               // å°è¯•è·å–æµåŠ¨æ€§æ± ä¿¡æ¯ - ä»£å¸åœ°å€å°±æ˜¯æ± å­åœ°å€
               const pairContract = new ethers.Contract(tokenAddress, PAIR_ABI, readProvider);
               const [reserve0, reserve1] = await pairContract.getReserves();
               const [token0, token1] = await Promise.all([
                 pairContract.token0(),
                 pairContract.token1()
               ]);
               
               if (token0.toLowerCase() === wokbAddress.toLowerCase()) {
                 // WOKBæ˜¯token0
                 liquidity = parseFloat(ethers.utils.formatEther(reserve0));
               } else if (token1.toLowerCase() === wokbAddress.toLowerCase()) {
                 // WOKBæ˜¯token1
                 liquidity = parseFloat(ethers.utils.formatEther(reserve1));
               }
             } catch (liquidityError) {
               console.warn('æ— æ³•è·å–æµåŠ¨æ€§ä¿¡æ¯:', liquidityError);
               // å°è¯•ä½œä¸ºPumpuä»£å¸è¯»å–
               try {
                 const pumpContract = new ethers.Contract(tokenAddress, PUMP_TOKEN_EXT_ABI, readProvider);
                 const [vEth, rEth] = await Promise.all([
                   pumpContract.virtualEth().catch(() => ethers.constants.Zero),
                   pumpContract.realEth().catch(() => ethers.constants.Zero)
                 ]);
                 liquidity = parseFloat(ethers.utils.formatEther(vEth.add(rEth)));
               } catch (pumpError) {
                 console.warn('æ— æ³•è·å–PumpuæµåŠ¨æ€§ä¿¡æ¯:', pumpError);
                 liquidity = 0;
               }
             }
             
             // è·å–ä»£å¸æ€»ä¾›åº”é‡å’Œç²¾åº¦ï¼Œè®¡ç®—å¸‚å€¼
             let totalSupply = 0;
             let marketCap = 0;
             try {
               const tokenContract = new ethers.Contract(tokenAddress, ERC20_METADATA_ABI, readProvider);
               const [supply, decimals] = await Promise.all([
                 tokenContract.totalSupply(),
                 tokenContract.decimals()
               ]);
               
               totalSupply = parseFloat(ethers.utils.formatUnits(supply, decimals));
               
               // è®¡ç®—å¸‚å€¼ï¼šæ€»ä¾›åº”é‡ Ã— ä»·æ ¼
               if (price > 0 && totalSupply > 0) {
                 marketCap = totalSupply * price;
               }
             } catch (capError) {
               console.warn('æ— æ³•è·å–å¸‚å€¼ä¿¡æ¯:', capError);
               totalSupply = 0;
               marketCap = 0;
             }
             
             return {
               price: price,
               liquidity: liquidity,
               totalSupply: totalSupply,
               marketCap: marketCap,
               timestamp: Date.now()
             };
           } catch (priceError) {
             console.warn('æ— æ³•è·å–ä»·æ ¼ä¿¡æ¯:', priceError);
             return {
               price: 0,
               liquidity: 0,
               totalSupply: 0,
               marketCap: 0,
               timestamp: Date.now()
             };
           }
         } catch (error) {
           console.error('è·å–DYORä»£å¸ä»·æ ¼å’ŒæµåŠ¨æ€§å¤±è´¥:', error);
           return {
             price: 0,
             liquidity: 0,
             totalSupply: 0,
             marketCap: 0,
             timestamp: Date.now()
           };
         }
       }
       
                // æ‰‹åŠ¨åˆ·æ–°å•ä¸ªDYORä»£å¸çš„ä»·æ ¼å’ŒæµåŠ¨æ€§
         async function refreshDYORTokenPrice(tokenAddress) {
           try {
             const token = deployedTokens.find(t => t.address === tokenAddress);
             if (!token) {
               throw new Error('ä»£å¸ä¸å­˜åœ¨');
             }
             
             if (okayMonitoredAddresses.has(tokenAddress)) {
               throw new Error('è¿™æ˜¯OKAYå‘å°„å°ä»£å¸ï¼Œæ— æ³•åˆ·æ–°DYORä»·æ ¼');
             }
             
             updateDYORPriceStatus(`ğŸ”„ æ­£åœ¨åˆ·æ–° ${token.description || 'ä»£å¸'} ä»·æ ¼...`, 'info');
             console.log(`ğŸ”„ æ­£åœ¨åˆ·æ–°ä»£å¸ ${token.description || tokenAddress} çš„ä»·æ ¼å’ŒæµåŠ¨æ€§...`);
             
             const priceData = await getDYORTokenPriceAndLiquidity(tokenAddress);
             
             if (priceData.price > 0) {
               token.price = priceData.price;
               token.liquidity = priceData.liquidity;
               token.totalSupply = priceData.totalSupply;
               token.marketCap = priceData.marketCap;
               token.lastPriceUpdate = priceData.timestamp;
               
               // è®¡ç®—ä»·æ ¼å˜åŒ–ç™¾åˆ†æ¯”
               if (token.lastPrice && token.lastPrice > 0) {
                 const priceChange = ((priceData.price - token.lastPrice) / token.lastPrice) * 100;
                 token.priceChange = priceChange;
               }
               
               token.lastPrice = priceData.price;
               
               // æ›´æ–°æ˜¾ç¤º
               updateTokenDisplay();
               
               // æ›´æ–°ä»·æ ¼æ¦‚è§ˆ
               updateDYORPriceSummary();
               
               const successMessage = `âœ… ${token.description || 'ä»£å¸'} ä»·æ ¼å·²æ›´æ–°: ${priceData.price.toFixed(6)} OKB`;
               updateDYORPriceStatus(successMessage, 'success');
               showNotification(successMessage, 'success');
               
               // 3ç§’åæ¢å¤é»˜è®¤çŠ¶æ€
               setTimeout(() => {
                 updateDYORPriceStatus('ğŸ”„ ç›‘æ§ä¸­...', 'info');
               }, 3000);
             } else {
               const warningMessage = `âš ï¸ æ— æ³•è·å– ${token.description || 'ä»£å¸'} çš„ä»·æ ¼ä¿¡æ¯`;
               updateDYORPriceStatus(warningMessage, 'warning');
               showNotification(warningMessage, 'warning');
               
               // 3ç§’åæ¢å¤é»˜è®¤çŠ¶æ€
               setTimeout(() => {
                 updateDYORPriceStatus('ğŸ”„ ç›‘æ§ä¸­...', 'info');
               }, 3000);
             }
           } catch (error) {
             console.error('åˆ·æ–°ä»£å¸ä»·æ ¼å¤±è´¥:', error);
             showNotification(`âŒ åˆ·æ–°ä»·æ ¼å¤±è´¥: ${error.message}`, 'error');
           }
         }
         
                  // æ‰¹é‡æ›´æ–°DYORå‘å°„å°ä»£å¸çš„ä»·æ ¼å’ŒæµåŠ¨æ€§
         async function updateDYORTokensPriceAndLiquidity() {
           try {
             const dyorTokens = deployedTokens.filter(token => 
               !okayMonitoredAddresses.has(token.address) && token.status === 'opened'
             );
             
             if (dyorTokens.length === 0) {
               updateDYORPriceStatus('ğŸ“Š æš‚æ— å¼€ç›˜çš„DYORä»£å¸', 'info');
               return;
             }
             
             updateDYORPriceStatus(`ğŸ”„ æ­£åœ¨æ›´æ–° ${dyorTokens.length} ä¸ªä»£å¸çš„ä»·æ ¼...`, 'info');
             console.log(`ğŸ”„ æ­£åœ¨æ›´æ–° ${dyorTokens.length} ä¸ªDYORå‘å°„å°ä»£å¸çš„ä»·æ ¼å’ŒæµåŠ¨æ€§...`);
             
             let updatedCount = 0;
             for (const token of dyorTokens) {
               try {
                 const priceData = await getDYORTokenPriceAndLiquidity(token.address);
                 
                 // æ›´æ–°ä»£å¸æ•°æ®
                 if (priceData.price > 0) {
                   token.price = priceData.price;
                   token.liquidity = priceData.liquidity;
                   token.totalSupply = priceData.totalSupply;
                   token.marketCap = priceData.marketCap;
                   token.lastPriceUpdate = priceData.timestamp;
                   
                   // è®¡ç®—ä»·æ ¼å˜åŒ–ç™¾åˆ†æ¯”
                   if (token.lastPrice && token.lastPrice > 0) {
                     const priceChange = ((priceData.price - token.lastPrice) / token.lastPrice) * 100;
                     token.priceChange = priceChange;
                     
                     // æ£€æŸ¥ä»·æ ¼å˜åŒ–è­¦æŠ¥
                     checkDYORPriceAlerts(token);
                   }
                   
                   token.lastPrice = priceData.price;
                   updatedCount++;
                 }
                 
                 // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡äºé¢‘ç¹
                 await new Promise(resolve => setTimeout(resolve, 100));
               } catch (error) {
                 console.warn(`æ›´æ–°ä»£å¸ ${token.address} ä»·æ ¼å¤±è´¥:`, error);
               }
             }
             
             // æ›´æ–°æ˜¾ç¤º
             updateTokenDisplay();
             
             // æ›´æ–°ä»·æ ¼æ¦‚è§ˆ
             updateDYORPriceSummary();
             
             // ä¿å­˜æ›´æ–°åçš„æ•°æ®åˆ°Firebase
             try {
               await saveToFirebase({
                 tokens: deployedTokens,
                 tokenData: tokenData,
                 lastUpdated: Date.now()
               }, 'pumpu_tokens');
               console.log('âœ… ä»·æ ¼æ•°æ®å·²ä¿å­˜åˆ°Firebase');
             } catch (firebaseError) {
               console.warn('ä¿å­˜ä»·æ ¼æ•°æ®åˆ°Firebaseå¤±è´¥:', firebaseError);
             }
             
             const statusMessage = `âœ… å·²æ›´æ–° ${updatedCount}/${dyorTokens.length} ä¸ªä»£å¸ä»·æ ¼`;
             updateDYORPriceStatus(statusMessage, 'success');
             console.log('âœ… DYORå‘å°„å°ä»£å¸ä»·æ ¼å’ŒæµåŠ¨æ€§æ›´æ–°å®Œæˆ');
             
             // 3ç§’åæ¢å¤é»˜è®¤çŠ¶æ€
             setTimeout(() => {
               updateDYORPriceStatus('ğŸ”„ ç›‘æ§ä¸­...', 'info');
             }, 3000);
           } catch (error) {
             console.error('æ‰¹é‡æ›´æ–°DYORä»£å¸ä»·æ ¼å¤±è´¥:', error);
             updateDYORPriceStatus('âŒ æ›´æ–°å¤±è´¥', 'error');
           }
         }
       
       // ä»OKAYç›‘æ§ä¸­ç§»é™¤ä»£å¸
       async function removeFromOkayMonitoring(address) {
         if (confirm('ç¡®å®šè¦ä»OKAYç›‘æ§ä¸­ç§»é™¤è¯¥ä»£å¸å—ï¼Ÿ')) {
           try {
             okayMonitoredAddresses.delete(address);
             
             // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
             saveOkayMonitoredTokens();
             
             // ä¿å­˜åˆ°Firebase
             await saveToFirebase({
               okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // æ›´æ–°æ˜¾ç¤º
             updateOkayMonitoringDisplay();
             
             // æ·»åŠ å†å²è®°å½•
             const token = tokenData[address];
             addHistoryRecord('monitor', `ä»OKAYç›‘æ§ç§»é™¤: ${token?.name || token?.description || 'Unknown Token'}`, address, {
               description: token?.name || token?.description
             });
             
             showNotification('å·²ä»OKAYç›‘æ§ä¸­ç§»é™¤', 'success');
           } catch (error) {
             console.error('ç§»é™¤OKAYç›‘æ§ä»£å¸å¤±è´¥:', error);
             alert('ç§»é™¤å¤±è´¥: ' + error.message);
           }
         }
       }
       
       // æ¸…ç©ºæ‰€æœ‰OKAYç›‘æ§ä»£å¸
       async function clearAllOkayTokens() {
         if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰OKAYç›‘æ§ä»£å¸å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
           try {
             okayMonitoredAddresses.clear();
             
             // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
             saveOkayMonitoredTokens();
             
             // ä¿å­˜åˆ°Firebase
             await saveToFirebase({
               okayMonitoredAddresses: [],
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // æ›´æ–°æ˜¾ç¤º
             updateOkayMonitoringDisplay();
             
             // æ·»åŠ å†å²è®°å½•
             addHistoryRecord('monitor', 'æ¸…ç©ºæ‰€æœ‰OKAYç›‘æ§ä»£å¸', null, {});
             
             showNotification('å·²æ¸…ç©ºæ‰€æœ‰OKAYç›‘æ§ä»£å¸', 'success');
           } catch (error) {
             console.error('æ¸…ç©ºOKAYç›‘æ§ä»£å¸å¤±è´¥:', error);
             alert('æ¸…ç©ºå¤±è´¥: ' + error.message);
           }
         }
       }
       
       // åˆ›å»ºå‘å°„å°ç»Ÿè®¡ä¿¡æ¯
       function createLaunchpadStats(launchpadType, tokens) {
         const totalTokens = tokens.length;
         const openedTokens = tokens.filter(t => t.status === 'opened').length;
         const pendingTokens = tokens.filter(t => t.status === 'pending').length;
         const newTokens = tokens.filter(t => t.status === 'new').length;
         
         const statsClass = launchpadType === 'okay' ? 'okay' : '';
         const title = launchpadType === 'okay' ? 'OKAYå‘å°„å°ç»Ÿè®¡' : 'DYORå‘å°„å°ç»Ÿè®¡';
         
         // ä¸ºDYORå‘å°„å°æ·»åŠ ä»·æ ¼ã€æµåŠ¨æ€§å’Œå¸‚å€¼ç»Ÿè®¡
         let additionalStats = '';
         if (launchpadType !== 'okay') {
           const tokensWithPrice = tokens.filter(t => t.status === 'opened' && t.price && t.price > 0);
           const avgPrice = tokensWithPrice.length > 0 ? 
             (tokensWithPrice.reduce((sum, t) => sum + t.price, 0) / tokensWithPrice.length).toFixed(6) : '0';
           const totalLiquidity = tokensWithPrice.reduce((sum, t) => sum + (t.liquidity || 0), 0).toFixed(2);
           const totalMarketCap = tokensWithPrice.reduce((sum, t) => sum + (t.marketCap || 0), 0);
           
           additionalStats = `
             <div class="stat-item">
               <div class="stat-value">${avgPrice}</div>
               <div class="stat-label">å¹³å‡ä»·æ ¼(OKB)</div>
             </div>
             <div class="stat-item">
               <div class="stat-value">${totalLiquidity}</div>
               <div class="stat-label">æ€»æ± å­OKB</div>
             </div>
             <div class="stat-item">
               <div class="stat-value">${formatMarketCap(totalMarketCap)}</div>
               <div class="stat-label">æ€»å¸‚å€¼</div>
             </div>
           `;
         }
         
         return `
           <div class="launchpad-stats ${statsClass}">
             <h3>ğŸ“Š ${title}</h3>
             <div class="stats-grid">
               <div class="stat-item">
                 <div class="stat-value">${totalTokens}</div>
                 <div class="stat-label">æ€»ä»£å¸æ•°</div>
               </div>
               <div class="stat-item">
                 <div class="stat-value">${openedTokens}</div>
                 <div class="stat-label">å·²å¼€ç›˜</div>
               </div>
               <div class="stat-item">
                 <div class="stat-value">${pendingTokens}</div>
                 <div class="stat-label">å³å°†æ‰“æ»¡</div>
               </div>
               <div class="stat-item">
                 <div class="stat-value">${newTokens}</div>
                 <div class="stat-label">æ–°åˆ›å»º</div>
               </div>
               ${additionalStats}
             </div>
           </div>
         `;
       }
       
       
       
       // å¢å¼ºçš„é€šçŸ¥ç³»ç»Ÿ
           function showNotification(message, type = 'info', duration = 3000) {
           if (!userPreferences.notificationEnabled) return;
           
           const notification = document.createElement('div');
           notification.className = `notification ${type}`;
           notification.textContent = message;
           
           document.body.appendChild(notification);
           
           // æ’­æ”¾å£°éŸ³æé†’
           if (userPreferences.soundEnabled && type === 'success') {
             playNotificationSound();
           }
           
           setTimeout(() => {
             if (notification.parentElement) {
               notification.remove();
             }
           }, duration);
         }
         
         // å£°éŸ³æé†’
         function playNotificationSound() {
           try {
             // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡æ’­æ”¾æç¤ºéŸ³
             const audioContext = new (window.AudioContext || window.webkitAudioContext)();
             const oscillator = audioContext.createOscillator();
             const gainNode = audioContext.createGain();
             
             oscillator.connect(gainNode);
             gainNode.connect(audioContext.destination);
             
             oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
             oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
             oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
             
             gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
             gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
             
             oscillator.start(audioContext.currentTime);
             oscillator.stop(audioContext.currentTime + 0.3);
           } catch (error) {
             console.error('æ’­æ”¾å£°éŸ³å¤±è´¥:', error);
           }
         }
         
         // ä»·æ ¼ç›‘æ§ç³»ç»Ÿ
         function startPriceMonitoring() {
           console.log('ğŸš€ å¯åŠ¨ä»·æ ¼ç›‘æ§ç³»ç»Ÿ...');
           
           // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡ä»·æ ¼å˜åŒ–
           setInterval(() => {
             deployedTokens.forEach(token => {
               if (token.isMonitored && token.status === 'opened') {
                 checkPriceChange(token);
               }
             });
           }, 5000);
           
           // æ¯30ç§’æ›´æ–°DYORå‘å°„å°ä»£å¸çš„ä»·æ ¼å’ŒæµåŠ¨æ€§
           setInterval(async () => {
             await updateDYORTokensPriceAndLiquidity();
           }, 30000);
           
           // ç«‹å³æ‰§è¡Œä¸€æ¬¡ä»·æ ¼æ›´æ–°
           setTimeout(async () => {
             await updateDYORTokensPriceAndLiquidity();
           }, 2000);
           
           // åˆå§‹åŒ–ä»·æ ¼æ¦‚è§ˆ
           setTimeout(() => {
             updateDYORPriceSummary();
           }, 1000);
           
           showNotification('âœ… DYORå‘å°„å°ä»£å¸ä»·æ ¼ç›‘æ§å·²å¯åŠ¨', 'success');
         }
         
         function checkPriceChange(token) {
           const currentPrice = token.price || 0;
           const lastPrice = token.lastPrice || currentPrice;
           
           if (lastPrice > 0 && currentPrice > 0) {
             const changePercent = Math.abs(currentPrice - lastPrice) / lastPrice;
             
             if (changePercent >= userPreferences.priceChangeThreshold) {
               const direction = currentPrice > lastPrice ? 'ä¸Šæ¶¨' : 'ä¸‹è·Œ';
               const changeText = `${(changePercent * 100).toFixed(2)}%`;
               
               showNotification(
                 `${token.description || 'ä»£å¸'} ä»·æ ¼${direction} ${changeText}`,
                 currentPrice > lastPrice ? 'success' : 'warning'
               );
               
               if (userPreferences.soundEnabled) {
                 playNotificationSound();
               }
             }
           }
           
           token.lastPrice = currentPrice;
         }
         
         // æ›´æ–°DYORä»·æ ¼ç›‘æ§çŠ¶æ€æ˜¾ç¤º
         function updateDYORPriceStatus(message, type = 'info') {
           const statusElement = document.getElementById('dyor-price-status');
           if (statusElement) {
             const colors = {
               'info': '#00ff00',
               'success': '#00ff00',
               'warning': '#ffaa00',
               'error': '#ff4444'
             };
             
             statusElement.style.color = colors[type] || colors.info;
             statusElement.textContent = message;
           }
         }
         
         // æ›´æ–°DYORä»·æ ¼æ¦‚è§ˆæ˜¾ç¤º
         function updateDYORPriceSummary() {
           const summaryElement = document.getElementById('dyor-price-summary');
           const detailsElement = document.getElementById('dyor-price-details');
           
           if (!summaryElement || !detailsElement) return;
           
           const dyorTokens = deployedTokens.filter(token => 
             !okayMonitoredAddresses.has(token.address) && token.status === 'opened'
           );
           
           const tokensWithPrice = dyorTokens.filter(t => t.price && t.price > 0);
           
           if (tokensWithPrice.length === 0) {
             summaryElement.textContent = 'æš‚æ— ä»·æ ¼æ•°æ®';
             detailsElement.innerHTML = 'ç­‰å¾…ä»£å¸å¼€ç›˜æˆ–ä»·æ ¼æ›´æ–°...';
             return;
           }
           
           // è®¡ç®—ä»·æ ¼ç»Ÿè®¡
           const prices = tokensWithPrice.map(t => t.price);
           const minPrice = Math.min(...prices);
           const maxPrice = Math.max(...prices);
           const avgPrice = prices.reduce((sum, p) => sum + p, 0) / prices.length;
           
           const totalLiquidity = tokensWithPrice.reduce((sum, t) => sum + (t.liquidity || 0), 0);
           const totalMarketCap = tokensWithPrice.reduce((sum, t) => sum + (t.marketCap || 0), 0);
           
           // è®¡ç®—ä»·æ ¼å˜åŒ–ç»Ÿè®¡
           const tokensWithChange = tokensWithPrice.filter(t => t.priceChange !== undefined);
           const positiveChanges = tokensWithChange.filter(t => t.priceChange > 0);
           const negativeChanges = tokensWithChange.filter(t => t.priceChange < 0);
           
           summaryElement.textContent = `${tokensWithPrice.length}ä¸ªä»£å¸ | å¹³å‡ä»·æ ¼: ${avgPrice.toFixed(6)} OKB | æ€»å¸‚å€¼: ${formatMarketCap(totalMarketCap)}`;
           
           detailsElement.innerHTML = `
             <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 5px;">
               <div>æœ€ä½ä»·æ ¼: <span style="color: #00ff00;">${minPrice.toFixed(6)} OKB</span></div>
               <div>æœ€é«˜ä»·æ ¼: <span style="color: #ff4444;">${maxPrice.toFixed(6)} OKB</span></div>
               <div>æ€»æ± å­OKB: <span style="color: #00d8ff;">${totalLiquidity.toFixed(2)} OKB</span></div>
               <div>æ€»å¸‚å€¼: <span style="color: #ff00ff;">${formatMarketCap(totalMarketCap)}</span></div>
               <div>ä¸Šæ¶¨ä»£å¸: <span style="color: #00ff00;">${positiveChanges.length}ä¸ª</span></div>
               <div>ä¸‹è·Œä»£å¸: <span style="color: #ff4444;">${negativeChanges.length}ä¸ª</span></div>
               <div>ç¨³å®šä»£å¸: <span style="color: #aaa;">${tokensWithChange.length - positiveChanges.length - negativeChanges.length}ä¸ª</span></div>
             </div>
           `;
         }
         
         // æ£€æŸ¥DYORä»£å¸ä»·æ ¼å˜åŒ–å¹¶æ˜¾ç¤ºè­¦æŠ¥
         function checkDYORPriceAlerts(token) {
           if (!token.price || !token.lastPrice || token.lastPrice <= 0) return;
           
           const changePercent = Math.abs(token.price - token.lastPrice) / token.lastPrice;
           
           if (changePercent >= userPreferences.priceChangeThreshold) {
             const direction = token.price > token.lastPrice ? 'ğŸ“ˆ ä¸Šæ¶¨' : 'ğŸ“‰ ä¸‹è·Œ';
             const changeText = `${(changePercent * 100).toFixed(2)}%`;
             const currentPrice = token.price.toFixed(6);
             
             showNotification(
               `ğŸš€ DYORå‘å°„å°: ${token.description || 'ä»£å¸'} ${direction} ${changeText}<br/>å½“å‰ä»·æ ¼: ${currentPrice} OKB`,
               token.price > token.lastPrice ? 'success' : 'warning',
               5000
             );
             
             if (userPreferences.soundEnabled) {
               playNotificationSound();
             }
           }
         }
         
         // è®¾ç½®é¢æ¿
         function showSettings() {
           const panel = document.createElement('div');
           panel.className = 'settings-panel';
           panel.innerHTML = `
             <h3>âš™ï¸ è®¾ç½®</h3>
             <div class="setting-item">
               <label>å¯ç”¨å£°éŸ³æé†’</label>
               <input type="checkbox" id="soundEnabled" ${userPreferences.soundEnabled ? 'checked' : ''}>
             </div>
             <div class="setting-item">
               <label>å¯ç”¨å¼¹çª—é€šçŸ¥</label>
               <input type="checkbox" id="notificationEnabled" ${userPreferences.notificationEnabled ? 'checked' : ''}>
             </div>
             <div class="setting-item">
               <label>è‡ªåŠ¨åˆ·æ–°</label>
               <input type="checkbox" id="autoRefresh" ${userPreferences.autoRefresh ? 'checked' : ''}>
             </div>
             <div class="setting-item">
               <label>ä»·æ ¼å˜åŒ–é˜ˆå€¼ (%)</label>
               <input type="number" id="priceThreshold" value="${userPreferences.priceChangeThreshold * 100}" min="1" max="100">
             </div>
             <div class="setting-item">
               <label>æœ€å°æµåŠ¨æ€§é˜ˆå€¼ (OKB)</label>
               <input type="number" id="liquidityThreshold" value="${userPreferences.minLiquidityThreshold}" min="10" max="1000">
             </div>
             <div style="text-align: center; margin-top: 20px;">
               <button class="buy-btn" onclick="saveSettings()">ä¿å­˜è®¾ç½®</button>
               <button class="refresh-btn" onclick="closeSettings()" style="margin-left: 10px;">å–æ¶ˆ</button>
             </div>
           `;
           
           document.body.appendChild(panel);
           panel.style.display = 'block';
           
           // ç»‘å®šäº‹ä»¶
           document.getElementById('soundEnabled').addEventListener('change', (e) => {
             userPreferences.soundEnabled = e.target.checked;
           });
           
           document.getElementById('notificationEnabled').addEventListener('change', (e) => {
             userPreferences.notificationEnabled = e.target.checked;
           });
           
           document.getElementById('autoRefresh').addEventListener('change', (e) => {
             userPreferences.autoRefresh = e.target.checked;
           });
           
           document.getElementById('priceThreshold').addEventListener('change', (e) => {
             userPreferences.priceChangeThreshold = parseFloat(e.target.value) / 100;
           });
           
           document.getElementById('liquidityThreshold').addEventListener('change', (e) => {
             userPreferences.minLiquidityThreshold = parseFloat(e.target.value);
           });
         }
         
         function saveSettings() {
           saveUserPreferences();
           showNotification('è®¾ç½®å·²ä¿å­˜', 'success');
           closeSettings();
         }
         
         function closeSettings() {
           const panel = document.querySelector('.settings-panel');
           if (panel) {
             panel.remove();
           }
         }
         
         // å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰ä»£å¸çš„åç§°å’Œç¬¦å·
         async function forceRefreshTokenNames() {
           try {
             showNotification('ğŸ”„ æ­£åœ¨å¼ºåˆ¶åˆ·æ–°ä»£å¸åç§°...', 'info');
             
             const targets = deployedTokens.filter(t => t && t.address);
             let updated = 0;
             
             for (const token of targets) {
               try {
                 // å¼ºåˆ¶ä»åˆçº¦é‡æ–°è¯»å–åç§°å’Œç¬¦å·
                 const erc20Contract = new ethers.Contract(token.address, ERC20_METADATA_ABI, readProvider);
                 const [name, symbol] = await Promise.all([
                   erc20Contract.name().catch(() => ''),
                   erc20Contract.symbol().catch(() => '')
                 ]);
                 
                 let changed = false;
                 if (name && typeof name === 'string' && name.trim() && name !== token.name) {
                   token.name = name.trim();
                   changed = true;
                 }
                 if (symbol && typeof symbol === 'string' && symbol.trim() && symbol !== token.symbol) {
                   token.symbol = symbol.trim();
                   changed = true;
                 }
                 
                 if (changed) {
                   updated++;
                   console.log(`âœ… æ›´æ–°ä»£å¸ ${token.address}: name="${token.name}", symbol="${token.symbol}"`);
                   
                   // åŒæ­¥æ›´æ–° tokenData ä¸­çš„å¯¹åº”æ•°æ®
                   if (tokenData[token.address]) {
                     tokenData[token.address].name = token.name;
                     tokenData[token.address].symbol = token.symbol;
                   }
                 }
                 
                 // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
                 await new Promise(resolve => setTimeout(resolve, 100));
               } catch (e) {
                 console.warn(`åˆ·æ–°ä»£å¸ ${token.address} åç§°å¤±è´¥:`, e);
               }
             }
             
             // åŒæ­¥æ•°æ®æº
             syncTokenNames();
             
             // æ›´æ–°æ˜¾ç¤º
             updateTokenDisplay();
             
             // ä¿å­˜åˆ° Firebase
             try {
               await saveToFirebase({
                 tokens: deployedTokens,
                 tokenData: tokenData,
                 lastUpdated: Date.now()
               }, 'pumpu_tokens');
               console.log('âœ… åç§°æ›´æ–°å·²ä¿å­˜åˆ° Firebase');
             } catch (e) {
               console.warn('ä¿å­˜åç§°æ›´æ–°åˆ° Firebase å¤±è´¥:', e);
             }
             
             showNotification(`âœ… åç§°åˆ·æ–°å®Œæˆï¼š${updated}/${targets.length} ä¸ªä»£å¸å·²æ›´æ–°`, 'success');
           } catch (error) {
             console.error('å¼ºåˆ¶åˆ·æ–°ä»£å¸åç§°å¤±è´¥:', error);
             showNotification('âŒ åç§°åˆ·æ–°å¤±è´¥ï¼š' + error.message, 'error');
           }
         }
         
         // è·å–æ± å­è¯¦ç»†ä¿¡æ¯ï¼ˆOKBæ•°é‡ã€ä»£å¸æ•°é‡ã€ä»·æ ¼ç­‰ï¼‰
         async function getPoolDetails(tokenAddress) {
           try {
             if (!readProvider) {
               throw new Error('åªè¯»Provideræœªåˆå§‹åŒ–');
             }
             
             // å°è¯•ä½œä¸º UniswapV2 Pair è¯»å–
             try {
               const pair = new ethers.Contract(tokenAddress, PAIR_ABI, readProvider);
               const [reserve0, reserve1] = await pair.getReserves();
               const [token0, token1] = await Promise.all([
                 pair.token0(),
                 pair.token1()
               ]);
               
               const wokbLower = CONFIG.WOKB.toLowerCase();
               let okbReserve = 0;
               let tokenReserve = 0;
               let price = 0;
               
               if (token0.toLowerCase() === wokbLower) {
                 okbReserve = Number(ethers.utils.formatEther(reserve0));
                 tokenReserve = Number(ethers.utils.formatEther(reserve1));
               } else if (token1.toLowerCase() === wokbLower) {
                 okbReserve = Number(ethers.utils.formatEther(reserve1));
                 tokenReserve = Number(ethers.utils.formatEther(reserve0));
               }
               
               if (tokenReserve > 0) {
                 price = okbReserve / tokenReserve;
               }
               
               return {
                 okbAmount: okbReserve,
                 tokenAmount: tokenReserve,
                 price: price,
                 type: 'uniswap_v2_pair'
               };
             } catch (e) {
                                // å°è¯•ä½œä¸º Pumpu ä»£å¸è¯»å–
                 try {
                   const pump = new ethers.Contract(tokenAddress, PUMP_TOKEN_EXT_ABI, readProvider);
                   const [vEth, vTok] = await Promise.all([
                     pump.virtualEth().catch(() => ethers.constants.Zero),
                     pump.virtualToken().catch(() => ethers.constants.Zero)
                   ]);
                   
                   const okbReserve = Number(ethers.utils.formatEther(vEth));
                   const tokenReserve = Number(ethers.utils.formatEther(vTok));
                   let price = 0;
                   
                   if (tokenReserve > 0) {
                     price = okbReserve / tokenReserve;
                   }
                   
                   return {
                     okbAmount: okbReserve,
                     tokenAmount: tokenReserve,
                     price: price,
                     type: 'pumpu_token'
                   };
                 } catch (e2) {
                   throw new Error('æ— æ³•è¯†åˆ«æ± å­ç±»å‹');
                 }
             }
           } catch (error) {
             console.error('è·å–æ± å­è¯¦æƒ…å¤±è´¥:', error);
             return {
               okbAmount: 0,
               tokenAmount: 0,
               price: 0,
               type: 'unknown'
             };
           }
         }
         

         
         // åŒæ­¥ deployedTokens å’Œ tokenData ä¸­çš„åç§°æ•°æ®
         function syncTokenNames() {
           try {
             deployedTokens.forEach(token => {
               if (tokenData[token.address]) {
                 // å¦‚æœ deployedTokens ä¸­æœ‰åç§°ä½† tokenData ä¸­æ²¡æœ‰ï¼ŒåŒæ­¥è¿‡å»
                 if (token.name && !tokenData[token.address].name) {
                   tokenData[token.address].name = token.name;
                 }
                 if (token.symbol && !tokenData[token.address].symbol) {
                   tokenData[token.address].symbol = token.symbol;
                 }
                 
                 // å¦‚æœ tokenData ä¸­æœ‰åç§°ä½† deployedTokens ä¸­æ²¡æœ‰ï¼ŒåŒæ­¥è¿‡æ¥
                 if (tokenData[token.address].name && !token.name) {
                   token.name = tokenData[token.address].name;
                 }
                 if (tokenData[token.address].symbol && !token.symbol) {
                   token.symbol = tokenData[token.address].symbol;
                 }
               }
             });
             
             console.log('âœ… ä»£å¸åç§°æ•°æ®åŒæ­¥å®Œæˆ');
           } catch (error) {
             console.error('ä»£å¸åç§°æ•°æ®åŒæ­¥å¤±è´¥:', error);
           }
         }
         
         // æ ¼å¼åŒ–å¸‚å€¼æ˜¾ç¤º
         function formatMarketCap(marketCap) {
           if (marketCap >= 1000000) {
             return (marketCap / 1000000).toFixed(2) + 'M OKB';
           } else if (marketCap >= 1000) {
             return (marketCap / 1000).toFixed(2) + 'K OKB';
           } else {
             return marketCap.toFixed(2) + ' OKB';
           }
         }
         

         
         // æ˜¾ç¤ºæ± å­è¯¦ç»†ä¿¡æ¯
         async function showPoolDetails(tokenAddress) {
           try {
             showNotification('ğŸ”„ æ­£åœ¨è·å–æ± å­è¯¦æƒ…...', 'info');
             
             const poolInfo = await getPoolDetails(tokenAddress);
             const token = deployedTokens.find(t => t.address === tokenAddress) || tokenData[tokenAddress];
             
             if (!poolInfo || poolInfo.okbAmount === 0) {
               showNotification('âŒ æ— æ³•è·å–æ± å­ä¿¡æ¯', 'error');
               return;
             }
             
             // åˆ›å»ºæ± å­è¯¦æƒ…å¼¹çª—
             const modal = document.createElement('div');
             modal.style.cssText = `
               position: fixed;
               top: 0;
               left: 0;
               width: 100%;
               height: 100%;
               background: rgba(0, 0, 0, 0.8);
               z-index: 10003;
               display: flex;
               align-items: center;
               justify-content: center;
               animation: fadeIn 0.3s ease;
             `;
             
             modal.innerHTML = `
               <div style="background: #1e1e1e; padding: 30px; border-radius: 12px; border: 1px solid #2c2c2c; max-width: 500px; width: 90%;">
                 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                   <h3 style="color: #00d8ff; margin: 0;">ğŸŠ æ± å­è¯¦æƒ…</h3>
                   <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background: none; border: none; color: #aaa; font-size: 24px; cursor: pointer;">&times;</button>
                 </div>
                 
                 <div style="background: #2c2c2c; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                   <h4 style="color: #00ff00; margin-bottom: 15px;">${token?.name || token?.symbol || 'ä»£å¸'} æ± å­ä¿¡æ¯</h4>
                   
                   <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                     <div style="text-align: center; padding: 15px; background: #1e1e1e; border-radius: 6px;">
                       <div style="font-size: 24px; font-weight: bold; color: #00ff00;">${poolInfo.okbAmount.toFixed(2)}</div>
                       <div style="font-size: 12px; color: #aaa;">æ± å­OKBæ•°é‡</div>
                     </div>
                     
                     <div style="text-align: center; padding: 15px; background: #1e1e1e; border-radius: 6px;">
                       <div style="font-size: 24px; font-weight: bold; color: #00d8ff;">${poolInfo.tokenAmount.toLocaleString()}</div>
                       <div style="font-size: 12px; color: #aaa;">æ± å­ä»£å¸æ•°é‡</div>
                     </div>
                   </div>
                   
                   <div style="margin-top: 15px; padding: 15px; background: #1e1e1e; border-radius: 6px; text-align: center;">
                     <div style="font-size: 18px; font-weight: bold; color: #ff00ff;">${poolInfo.price.toFixed(8)} OKB</div>
                     <div style="font-size: 12px; color: #aaa;">å½“å‰ä»·æ ¼</div>
                   </div>
                   
                   <div style="margin-top: 10px; text-align: center;">
                     <span style="background: #333; color: #00d8ff; padding: 4px 8px; border-radius: 4px; font-size: 11px;">
                       æ± å­ç±»å‹: ${poolInfo.type === 'uniswap_v2_pair' ? 'Uniswap V2' : poolInfo.type === 'pumpu_token' ? 'Pumpu' : 'æœªçŸ¥'}
                     </span>

                   </div>
                 </div>
                 
                 <div style="text-align: center;">
                   <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background: #00d8ff; color: #000; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">å…³é—­</button>
                 </div>
               </div>
             `;
             
             document.body.appendChild(modal);
             showNotification('âœ… æ± å­è¯¦æƒ…å·²æ˜¾ç¤º', 'success');
             
           } catch (error) {
             console.error('æ˜¾ç¤ºæ± å­è¯¦æƒ…å¤±è´¥:', error);
             showNotification('âŒ æ˜¾ç¤ºæ± å­è¯¦æƒ…å¤±è´¥: ' + error.message, 'error');
           }
         }
         
         // å¢å¼ºçš„å¼€ç›˜é€šçŸ¥
         function showOpeningNotification(token) {
           showNotification(`ğŸš€ ${token.description || 'ä»£å¸'} å·²å¼€ç›˜ï¼`, 'success', 8000);
           
           // åˆ›å»ºæ›´é†’ç›®çš„å¼¹çª—
           const modal = document.createElement('div');
           modal.style.cssText = `
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background: rgba(0, 255, 0, 0.9);
             z-index: 10002;
             display: flex;
             align-items: center;
             justify-content: center;
             animation: fadeIn 0.5s ease;
           `;
           
           modal.innerHTML = `
             <div style="background: #000; padding: 40px; border-radius: 20px; text-align: center; max-width: 500px;">
               <h1 style="color: #00ff00; font-size: 48px; margin-bottom: 20px;">ğŸš€</h1>
               <h2 style="color: #fff; margin-bottom: 20px;">ä»£å¸å·²å¼€ç›˜ï¼</h2>
               <p style="color: #00ff00; font-size: 18px; margin-bottom: 20px;"><strong>${token.description || 'Unknown Token'}</strong></p>
               <p style="color: #ccc; margin-bottom: 30px;">åœ°å€: ${token.address.substring(0, 8)}...${token.address.substring(36)}</p>
               <button onclick="this.parentElement.parentElement.remove()" style="background: #00ff00; color: #000; padding: 15px 30px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer;">çŸ¥é“äº†</button>
             </div>
           `;
           
           document.body.appendChild(modal);
           
           // 10ç§’åè‡ªåŠ¨å…³é—­
           setTimeout(() => {
             if (modal.parentElement) {
               modal.remove();
             }
           }, 10000);
         }
         
         // æ›´æ–°åŒæ­¥çŠ¶æ€æ˜¾ç¤º
         function updateSyncStatus(status, message) {
           const indicator = document.getElementById('sync-indicator');
           if (indicator) {
             indicator.textContent = `${status} ${message}`;
           }
         }

                   // å®šæœŸä¿å­˜æ•°æ®åˆ° Firebase
          setInterval(async () => {
            try {
              updateSyncStatus('ğŸ”„', 'åŒæ­¥ä¸­...');
              await saveToFirebase({
                tokens: deployedTokens,
                tokenData: tokenData,
                monitoredAddresses: Array.from(monitoredAddresses),
                lastUpdated: Date.now()
              }, 'pumpu_tokens');
              
              // ä¿å­˜OKAYç›‘æ§ä»£å¸æ•°æ®
              await saveToFirebase({
                okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
                lastUpdated: Date.now()
              }, 'pumpu_okay_tokens');
              
              console.log('ğŸ”„ å®šæœŸä¿å­˜åˆ° Firebase å®Œæˆ');
              updateSyncStatus('âœ…', 'å·²åŒæ­¥');
              
              // 3ç§’åæ¢å¤é»˜è®¤çŠ¶æ€
              setTimeout(() => {
                updateSyncStatus('ğŸ”„', 'åŒæ­¥ä¸­...');
              }, 3000);
            } catch (error) {
              console.error('å®šæœŸä¿å­˜åˆ° Firebase å¤±è´¥:', error);
              updateSyncStatus('âŒ', 'åŒæ­¥å¤±è´¥');
            }
          }, 30000); // æ¯30ç§’ä¿å­˜ä¸€æ¬¡
         
         // æ·»åŠ è®¾ç½®æŒ‰é’®åˆ°é¡¶éƒ¨å¯¼èˆª
         document.addEventListener('DOMContentLoaded', () => {
           const topNav = document.querySelector('.top-nav');
           if (topNav) {
             const settingsBtn = document.createElement('button');
             settingsBtn.className = 'refresh-btn';
             settingsBtn.style.marginLeft = '10px';
             settingsBtn.textContent = 'âš™ï¸ è®¾ç½®';
             settingsBtn.onclick = showSettings;
             
             const searchDiv = topNav.querySelector('.search');
             if (searchDiv) {
               searchDiv.appendChild(settingsBtn);
             }
           }
         });

    // è§£æ DYOR ä»£å¸å¤´åƒï¼ˆä¼˜å…ˆ DexScreenerï¼Œå…¶æ¬¡ TrustWallet èµ„äº§åº“ï¼‰
    async function resolveDYORTokenImage(tokenAddress) {
      try {
        const checksum = ethers.utils.getAddress(tokenAddress);
        // 1) DexScreener
        try {
          const dsResp = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${checksum}`);
          if (dsResp.ok) {
            const dsJson = await dsResp.json();
            if (dsJson && Array.isArray(dsJson.pairs) && dsJson.pairs.length > 0) {
              const pair0 = dsJson.pairs[0];
              const img = pair0 && pair0.info && pair0.info.imageUrl ? pair0.info.imageUrl : '';
              if (img) return img;
            }
          }
        } catch (e) { console.warn('DexScreener æŸ¥è¯¢å¤±è´¥:', e); }
        // 2) TrustWallet
        try {
          const trustUrl = `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/xlayer/assets/${checksum}/logo.png`;
          const head = await fetch(trustUrl, { method: 'HEAD' });
          if (head.ok) return trustUrl;
        } catch (e2) { console.warn('TrustWallet å¤´åƒä¸å­˜åœ¨:', e2); }
        return '';
      } catch (err) { console.warn('è§£æ DYOR å¤´åƒå¤±è´¥:', err); return ''; }
    }

    // ä» DexScreener è§£æ DYOR åŸºæœ¬ä¿¡æ¯ï¼ˆname/symbol/imageï¼‰
    async function resolveDYORTokenMeta(tokenAddress) {
      try {
        const checksum = ethers.utils.getAddress(tokenAddress);
        // 1) ä¼˜å…ˆä» ERC20 åˆçº¦ç›´æ¥è¯»å– name/symbolï¼ˆæœ€å¿«ä¸”æœ€å¯é ï¼‰
        try {
          const erc20 = new ethers.Contract(checksum, ERC20_METADATA_ABI, readProvider);
          const [erc20Name, erc20Symbol] = await Promise.all([
            erc20.name().catch(() => ''),
            erc20.symbol().catch(() => '')
          ]);
          if ((erc20Name && typeof erc20Name === 'string') || (erc20Symbol && typeof erc20Symbol === 'string')) {
            return { name: erc20Name || '', symbol: erc20Symbol || '', imageUrl: '' };
          }
        } catch (e0) { /* å¿½ç•¥ï¼Œç»§ç»­ä½¿ç”¨ DexScreener å…œåº• */ }

        // 2) DexScreener å…œåº•
        try {
          const dsResp = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${checksum}`);
          if (!dsResp.ok) return { name: '', symbol: '', imageUrl: '' };
          const dsJson = await dsResp.json();
          if (!dsJson || !Array.isArray(dsJson.pairs) || dsJson.pairs.length === 0) {
            return { name: '', symbol: '', imageUrl: '' };
          }
          const pair0 = dsJson.pairs[0] || {};
          const base = pair0.baseToken || {};
          const info = pair0.info || {};
          return {
            name: base.name || '',
            symbol: base.symbol || '',
            imageUrl: info.imageUrl || ''
          };
        } catch (e1) {
          return { name: '', symbol: '', imageUrl: '' };
        }
      } catch (e) {
        console.warn('è§£æ DYOR åŸºæœ¬ä¿¡æ¯å¤±è´¥:', e);
        return { name: '', symbol: '', imageUrl: '' };
      }
    }

    // æ¸²æŸ“æœŸç¡®ä¿ DYOR å¤´åƒä¸åç§°/ç¬¦å·
    async function ensureDYORMeta(address) {
      try {
        const t = tokenData[address];
        if (!t || t.source === 'okay-monitoring') return;
        const needName = !t.name;
        const needSymbol = !t.symbol;
        const needImage = !t.image;
        if (!needName && !needSymbol && !needImage) return;

        // å…ˆç”¨ ERC20 è¯»å–ä¸€æ¬¡ï¼ˆæ›´å¯é ï¼‰
        let foundName = '';
        let foundSymbol = '';
        try {
          const erc20 = new ethers.Contract(address, ERC20_METADATA_ABI, readProvider);
          const [erc20Name, erc20Symbol] = await Promise.all([
            needName ? erc20.name().catch(() => '') : Promise.resolve(''),
            needSymbol ? erc20.symbol().catch(() => '') : Promise.resolve('')
          ]);
          foundName = (erc20Name && typeof erc20Name === 'string') ? erc20Name : '';
          foundSymbol = (erc20Symbol && typeof erc20Symbol === 'string') ? erc20Symbol : '';
        } catch (_) { /* å¿½ç•¥ */ }

        // å†ç”¨ DexScreener å…œåº•
        const meta = await resolveDYORTokenMeta(address);

        let changed = false;
        if (needName && (foundName || meta.name)) { tokenData[address].name = foundName || meta.name; changed = true; }
        if (needSymbol && (foundSymbol || meta.symbol)) { tokenData[address].symbol = foundSymbol || meta.symbol; changed = true; }
        if (needImage && meta.imageUrl) { tokenData[address].image = meta.imageUrl; changed = true; }
        if (changed) updateTokenDisplay();
      } catch (e) { console.warn('ensureDYORMeta å¤±è´¥:', e); }
    }

    // ä»æè¿°ä¸­æå–å¯èƒ½çš„ name/symbol å…œåº•
    function extractNameSymbolFromDescription(desc) {
      try {
        if (!desc || typeof desc !== 'string') return { name: '', symbol: '' };
        
        // å¦‚æœæè¿°æ˜¯çº¯URLï¼Œä¸æå–åç§°
        if (desc.match(/^https?:\/\/\S+$/)) {
          return { name: '', symbol: '' };
        }
        
        let text = desc.replace(/https?:\/\/\S+/g, ' ').replace(/[\u{1F300}-\u{1FAFF}\u{1F600}-\u{1F64F}]/gu, ' ').trim();
        text = text.replace(/[^A-Za-z0-9 _\-]/g, ' ').replace(/\s+/g, ' ').trim();
        
        if (!text || text.length < 2) return { name: '', symbol: '' };
        
        // å¸¸è§æ ¼å¼: NAME SYMBOL, NAME - SYMBOL, NAME(SYMBOL)
        const paren = text.match(/^([^()]{2,})\(([^()]{1,12})\)/);
        if (paren) return { name: paren[1].trim().slice(0, 24), symbol: paren[2].trim().slice(0, 12) };
        
        const dash = text.match(/^(.{2,})\s[-|â€“|â€”]\s([A-Za-z0-9]{1,12})/);
        if (dash) return { name: dash[1].trim().slice(0, 24), symbol: dash[2].trim().slice(0, 12) };
        
        const parts = text.split(' ');
        const symbolGuess = (parts.find(p => /^[A-Z0-9]{2,12}$/.test(p)) || '').slice(0, 12);
        const nameGuess = text.slice(0, 24).trim();
        
        // å¦‚æœæå–çš„åç§°å¤ªçŸ­æˆ–çœ‹èµ·æ¥ä¸åƒçœŸå®åç§°ï¼Œè¿”å›ç©º
        if (nameGuess.length < 2 || /^[0-9\s]+$/.test(nameGuess)) {
          return { name: '', symbol: '' };
        }
        
        return { name: nameGuess, symbol: symbolGuess };
      } catch { return { name: '', symbol: '' }; }
    }
   </script>
 
 </body>
</html>

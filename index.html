<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NEWOX 代币监控 - XLayer链</title>
  <script>
    (function loadEthersWithFallback() {
      var urls = [
        'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js',
        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
      ];
      function tryLoad(index) {
        if (index >= urls.length) {
          console.error('Failed to load ethers.js from all CDNs');
          return;
        }
        var s = document.createElement('script');
        s.src = urls[index];
        s.async = false;
        s.onload = function () { console.log('ethers.js loaded from', urls[index]); };
        s.onerror = function () { console.warn('CDN failed:', urls[index]); tryLoad(index + 1); };
        document.head.appendChild(s);
      }
      tryLoad(0);
    })();
    // 批量回填历史代币缺失的 name/symbol，并同步到 Firebase
    async function backfillMissingMeta() {
      try {
        const targets = (deployedTokens || []).filter(t => t && t.address && (!t.name || !t.symbol));
        if (targets.length === 0) {
          showNotification('没有需要修复的代币名称', 'info');
          return;
        }
        showNotification(`开始修复 ${targets.length} 个代币名称...`, 'info');
        let fixed = 0;
        for (const t of targets) {
          try {
            if (t.source === 'okay-monitoring') {
              const info = await getTokenInfoFromContract(t.address);
              if (info) {
                if (info.name && !t.name) t.name = info.name;
                if (info.symbol && !t.symbol) t.symbol = info.symbol;
                if (info.image && !t.image) t.image = info.image;
                fixed++;
              }
            } else {
              await ensureDYORMeta(t.address);
              if (t.name || t.symbol) fixed++;
            }
          } catch (e) {
            console.warn('单个代币修复失败:', t?.address, e);
          }
          // 轻微延时，避免请求过快
          await new Promise(r => setTimeout(r, 80));
        }
        updateTokenDisplay();
        try {
          await saveToFirebase({
            tokens: deployedTokens,
            tokenData: tokenData,
            lastUpdated: Date.now()
          }, 'pumpu_tokens');
        } catch (e) { console.warn('修复后同步 Firebase 失败:', e); }
        showNotification(`名称修复完成：${fixed}/${targets.length}`, 'success');
      } catch (err) {
        console.error('批量回填名称失败:', err);
        showNotification('修复失败：' + (err?.message || err), 'error');
      }
    }
  </script>
     <!-- 移除对不存在的config.js的引用 -->
  <style>
    /* 重置 & 基础样式 */
    * {
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      font-family: "Helvetica Neue", Arial, sans-serif;
    }
    body {
      background-color: #121212; 
      color: #fff; 
      line-height: 1.4; 
      overflow-y: auto; 
    }
    a {
      color: #fff; 
      text-decoration: none;
    }
    
    /* 顶部导航 */
    .top-nav {
      display: flex; 
      align-items: center; 
      justify-content: space-between;
      background-color: #1e1e1e; 
      padding: 10px 20px;
      border-bottom: 1px solid #2c2c2c;
    }
    .top-nav .logo {
      font-size: 20px; 
      font-weight: bold; 
      color: #00d8ff;
    }
         .top-nav .menu {
       display: flex; 
       gap: 20px;
     }
     .top-nav .menu a {
       padding: 8px 12px;
       border-radius: 4px;
       transition: all 0.3s ease;
       position: relative;
     }
     .top-nav .menu a:hover {
       background-color: rgba(0, 216, 255, 0.1);
       transform: translateY(-1px);
     }
     .top-nav .menu a.active {
       color: #00d8ff !important;
       font-weight: bold !important;
       border-bottom: 2px solid #00d8ff !important;
     }
    .top-nav .search {
      display: flex; 
      align-items: center; 
      background-color: #2c2c2c; 
      padding: 5px 10px; 
      border-radius: 4px;
    }
    .top-nav .search input {
      background: transparent; 
      border: none; 
      color: #fff; 
      outline: none; 
      margin-left: 5px;
    }
    
    /* 钱包连接按钮 */
    .connect-wallet {
      background-color: #00d8ff;
      color: #000;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      border: none;
      margin-left: 20px;
    }
    .connect-wallet:hover {
      background-color: #00b8d9;
    }
    .wallet-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .wallet-address {
      font-size: 12px;
      color: #00d8ff;
      background-color: #2c2c2c;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    /* 状态指示器 */
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .status-live {
      background-color: #00ff00;
      animation: pulse 2s infinite;
    }
    .status-pending {
      background-color: #ffaa00;
    }
    .status-closed {
      background-color: #ff4444;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* 容器 & 列表布局 */
    .container {
      display: flex; 
      padding: 20px; 
      gap: 20px;
    }
    .column {
      flex: 1; 
      background-color: #1e1e1e; 
      border-radius: 8px; 
      padding: 15px; 
      border: 1px solid #2c2c2c;
    }
    .column h2 {
      font-size: 16px; 
      margin-bottom: 15px; 
      color: #fff; 
      opacity: 0.9;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .refresh-btn {
      background-color: #333;
      color: #fff;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .refresh-btn:hover {
      background-color: #444;
    }
    
    .card {
      display: flex; 
      align-items: center; 
      background-color: #2c2c2c; 
      border-radius: 6px; 
      padding: 10px; 
      margin-bottom: 10px; 
      gap: 10px;
      border-left: 4px solid #00d8ff;
      transition: all 0.3s ease;
    }
         .card:hover {
       transform: translateY(-2px);
       box-shadow: 0 4px 12px rgba(0, 216, 255, 0.2);
     }
     
     /* 发射台标识样式 */
     .launchpad-badge {
       display: inline-block;
       padding: 2px 8px;
       border-radius: 12px;
       font-size: 10px;
       font-weight: bold;
       margin-left: 8px;
       text-transform: uppercase;
       letter-spacing: 0.5px;
     }
     
     .okay-launchpad .launchpad-badge {
       background-color: #00ff00;
       color: #000;
     }
     
     .dyor-launchpad .launchpad-badge {
       background-color: #00d8ff;
       color: #000;
     }
     
     /* 不同发射台代币的边框颜色 */
     .card.okay-launchpad {
       border-left-color: #00ff00;
     }
     
     .card.dyor-launchpad {
       border-left-color: #00d8ff;
     }
     
     .card.okay-launchpad:hover {
       box-shadow: 0 4px 12px rgba(0, 255, 0, 0.3);
     }
     
     .card.dyor-launchpad:hover {
       box-shadow: 0 4px 12px rgba(0, 216, 255, 0.3);
     }
     
     /* 发射台统计信息样式 */
     .launchpad-stats {
       background: #2c2c2c;
       padding: 15px;
       border-radius: 8px;
       margin-bottom: 15px;
       border-left: 4px solid #00d8ff;
     }
     
     .launchpad-stats.okay {
       border-left-color: #00ff00;
     }
     

     
     .launchpad-stats h3 {
       color: #00d8ff;
       margin-bottom: 10px;
       font-size: 14px;
     }
     
     .launchpad-stats.okay h3 {
       color: #00ff00;
     }
     

     
     .launchpad-stats .stats-grid {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 10px;
     }
     
     .launchpad-stats .stat-item {
       text-align: center;
       padding: 8px;
       background: #1e1e1e;
       border-radius: 4px;
     }
     
     .launchpad-stats .stat-value {
       font-size: 18px;
       font-weight: bold;
       color: #00d8ff;
     }
     
     .launchpad-stats.okay .stat-value {
       color: #00ff00;
     }
     

     
     .launchpad-stats .stat-label {
       font-size: 11px;
       color: #aaa;
       margin-top: 2px;
     }
     
     /* 价格变化指示器样式 */
     .price-change {
       display: inline-block;
       padding: 2px 6px;
       border-radius: 3px;
       font-size: 11px;
       font-weight: bold;
       margin-left: 5px;
     }
     
     .price-change.positive {
       background: #00ff00;
       color: #000;
     }
     
     .price-change.negative {
       background: #ff4444;
       color: #fff;
     }
    .card .avatar {
      width: 40px; 
      height: 40px; 
      border-radius: 50%; 
      background-color: #333; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: bold; 
      color: #fff;
      flex-shrink: 0;
      overflow: hidden;
    }
    .card .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .card .info {
      flex: 1;
    }
    .card .info .title {
      font-size: 14px; 
      font-weight: bold; 
      margin-bottom: 4px; 
      color: #fff;
      display: flex;
      align-items: center;
    }
    .card .info .desc {
      font-size: 12px; 
      color: #aaa; 
      line-height: 1.4;
    }
    .card .stats {
      font-size: 12px; 
      color: #ccc; 
      text-align: right;
    }
    .buy-btn {
      background-color: #00d8ff; 
      color: #000; 
      font-size: 12px; 
      padding: 4px 8px; 
      border-radius: 4px; 
      cursor: pointer; 
      margin-left: 10px; 
      display: inline-block;
      transition: background-color 0.3s ease;
    }
    .buy-btn:hover {
      background-color: #00b8d9;
    }
    
    /* 加载状态 */
    .loading {
      text-align: center;
      padding: 20px;
      color: #aaa;
    }
    .spinner {
      border: 2px solid #333;
      border-top: 2px solid #00d8ff;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
         /* 代币详情模态框 */
     .modal {
       display: none;
       position: fixed;
       z-index: 1000;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.8);
     }
     .modal-content {
       background-color: #1e1e1e;
       margin: 3vh auto;
       padding: 30px;
       border-radius: 12px;
       width: 95%;
       max-width: 900px;
       max-height: 94vh;
       border: 1px solid #2c2c2c;
       box-sizing: border-box;
     }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close:hover {
      color: #fff;
    }
         .token-details {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 25px;
     }
     .detail-item {
       background-color: #2c2c2c;
       padding: 20px;
       border-radius: 8px;
     }
    .detail-item h4 {
      color: #00d8ff;
      margin-bottom: 10px;
    }
    
         /* 响应式设计 */
     @media (max-width: 768px) {
       .container {
         flex-direction: column;
       }
       .top-nav .menu {
         display: none;
       }
       .token-details {
         grid-template-columns: 1fr;
       }
       
       /* 移动端模态框优化 */
       .modal-content {
         width: 98%;
         margin: 1vh auto;
         padding: 20px;
         max-height: 98vh;
       }
       
       .token-details {
         gap: 15px;
       }
       
       .detail-item {
         padding: 12px;
       }
     }
  </style>
</head>
<body>

  <!-- 顶部导航 -->
      <div class="top-nav">
      <div class="logo">NEWOX 代币监控</div>
             <div class="menu">
         <a href="#" onclick="showHome()" style="color: #00d8ff; font-weight: bold;">🏠 首页</a>
         <a href="#" onclick="showColumn('new')">新创建</a>
         <a href="#" onclick="showColumn('pending')">即将打满</a>
         <a href="#" onclick="showColumn('opened')">已开盘</a>
                   <a href="#" onclick="showColumn('monitoring')">🚀 DYOR发射台</a>
          <a href="#" onclick="showColumn('okay-monitoring')">🚀 OKAY发射台</a>
         <a href="#" onclick="showColumn('history')">📚 历史记录</a>
+        <a href="https://x.com/xnew_okx?s=21" target="_blank" rel="noopener noreferrer">🐦 官方推特</a>
       </div>
      <div id="sync-status" style="color: #00d8ff; font-size: 12px; margin-right: 10px;">
        <span id="sync-indicator">🔄 同步中...</span>
      </div>
    <div class="search">
      <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
        <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.098ZM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"/>
      </svg>
      <input type="text" placeholder="搜索代币/钱包" onkeyup="searchTokens(this.value)" />
      <input id="trackAddressInput" type="text" placeholder="输入合约地址添加监控" style="margin-left:10px; min-width:240px;" onkeydown="if(event.key==='Enter'){trackAddressFromTopBar()}" />
      <button class="refresh-btn" style="margin-left:6px;" onclick="trackAddressFromTopBar()">添加</button>
      <!-- 修复按钮：已隐藏（代币名称已正常显示） -->
      <button id="fix-meta-btn" class="refresh-btn" style="margin-left:6px; display:none;" onclick="forceRefreshTokenNames()">修复名称</button>
    </div>
    <div id="wallet-section">
      <button class="connect-wallet" onclick="connectWallet()">连接钱包</button>
    </div>
  </div>

     <!-- 面包屑导航 -->
   <div id="breadcrumb" style="padding: 10px 20px; color: #00d8ff; font-size: 14px; border-bottom: 1px solid #2c2c2c;">
     <span id="current-page">🏠 首页 - 监控概览</span>
   </div>

   <!-- 主容器：分三列 -->
   <div class="container">
    <!-- 第一列：新创建 -->
    <div class="column" id="new-tokens">
      <h2>
        新创建
        <button class="refresh-btn" onclick="refreshNewTokens()">刷新</button>
      </h2>
      <div class="loading">
        <div class="spinner"></div>
        正在监听新代币...
      </div>
    </div>

    <!-- 第二列：即将打满 -->
    <div class="column" id="pending-tokens">
      <h2>
        即将打满
        <button class="refresh-btn" onclick="refreshPendingTokens()">刷新</button>
      </h2>
      <div class="loading">
        <div class="spinner"></div>
        加载中...
      </div>
    </div>

    <!-- 第三列：已开盘 -->
    <div class="column" id="opened-tokens">
      <h2>
        已开盘
        <button class="refresh-btn" onclick="refreshOpenedTokens()">刷新</button>
      </h2>
      <div class="loading">
        <div class="spinner"></div>
        加载中...
      </div>
    </div>
               <!-- 第四列：DYOR发射台监控 -->
      <div class="column" id="monitoring-tokens" style="display:none;">
        <h2>
          🚀 DYOR发射台监控
          <button class="refresh-btn" onclick="refreshMonitoringTokens()">刷新</button>
          <button class="refresh-btn" onclick="updateDYORTokensPriceAndLiquidity()" style="margin-left: 5px; background: #00d8ff;">更新价格</button>
        </h2>
        <div class="price-monitoring-status" style="background: #1e1e1e; padding: 10px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #00d8ff;">
          <div style="display: flex; align-items: center; justify-content: space-between;">
            <span style="color: #00d8ff; font-weight: bold;">💰 价格监控状态</span>
            <span id="dyor-price-status" style="color: #00ff00;">🔄 监控中...</span>
          </div>
          <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
            自动更新间隔: 30秒 | 价格变化阈值: ${(userPreferences.priceChangeThreshold * 100).toFixed(1)}%
          </div>
        </div>
        
        <div class="price-summary" style="background: #1e1e1e; padding: 10px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #00d8ff;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <span style="color: #00d8ff; font-weight: bold;">📊 价格概览</span>
            <span id="dyor-price-summary" style="color: #aaa;">加载中...</span>
          </div>
          <div id="dyor-price-details" style="font-size: 12px; color: #aaa;">
            <!-- 动态填充价格详情 -->
          </div>
        </div>
        <div class="loading">
          <div class="spinner"></div>
          暂无DYOR发射台监控代币
        </div>
      </div>
      
      <!-- 第五列：OKAY发射台监控 -->
      <div class="column" id="okay-monitoring-tokens" style="display:none;">
        <h2>
          🚀 OKAY发射台监控
          <button class="refresh-btn" onclick="refreshOkayMonitoringTokens()">刷新</button>
          <button class="refresh-btn" onclick="addOkayToken()" style="margin-left: 5px; background: #00ff00;">添加代币</button>
        <button class="refresh-btn" onclick="testSpecificToken()" style="margin-left: 5px; background: #ff8800;">测试指定代币</button>
          <button class="refresh-btn" onclick="clearAllOkayTokens()" style="margin-left: 5px; background: #ff4444;">清空所有</button>
        </h2>
        <div class="loading">
          <div class="spinner"></div>
          暂无OKAY发射台监控代币
        </div>
      </div>
     
     <!-- 第六列：历史记录 -->
     <div class="column" id="history-tokens" style="display:none;">
       <h2>
         历史记录
         <button class="refresh-btn" onclick="refreshHistoryTokens()">刷新</button>
         <button class="refresh-btn" onclick="clearHistory()" style="margin-left: 5px; background: #ff4444;">清空</button>
       </h2>
       <div class="history-filters">
         <select id="historyTypeFilter" onchange="filterHistory()">
           <option value="all">全部记录</option>
           <option value="created">代币创建</option>
           <option value="status_change">状态变化</option>
           <option value="purchase">购买记录</option>
           <option value="monitor">监控操作</option>
         </select>
         <input type="date" id="historyDateFilter" onchange="filterHistory()" style="margin-left: 10px;">
       </div>
       <div class="loading">
         <div class="spinner"></div>
         加载历史记录中...
       </div>
     </div>
   </div>

     <!-- 代币详情模态框 -->
   <div id="tokenModal" class="modal">
     <div class="modal-content">
       <div class="modal-header">
         <h3 id="modalTitle">代币详情</h3>
         <span class="close" onclick="closeModal()">&times;</span>
       </div>
       <div class="token-details" id="modalDetails">
         <!-- 动态填充内容 -->
       </div>
     </div>
   </div>

               <!-- 购买界面模态框 -->
     <div id="buyModal" class="modal">
       <div class="modal-content" style="max-width: 700px; max-height: 85vh;">
         <div class="modal-header">
           <h3 id="buyModalTitle">购买代币</h3>
           <span class="close" onclick="closeBuyModal()">&times;</span>
         </div>
         <div id="buyModalContent">
           <!-- 动态填充购买界面 -->
         </div>
       </div>
     </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
  
  <script>
    // Firebase 配置
    const firebaseConfig = {
      apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
      authDomain: "chat-294cc.firebaseapp.com",
      databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
      projectId: "chat-294cc",
      storageBucket: "chat-294cc.firebasestorage.app",
      messagingSenderId: "913615304269",
      appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
      measurementId: "G-SJR9NDW86B"
    };

    // 初始化 Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

         // 配置
     const CONFIG = {
       XLAYER_RPC: 'https://xlayerrpc.okx.com', // XLayer主网RPC（OKX官方节点）
       XLAYER_RPC_BACKUP: 'https://rpc.xlayer.com', // 备用RPC端点
       XLAYER_CHAIN_ID_HEX: '0xC4', // 196 (XLayer 主网)
       PUMPU_FACTORY: '0xC4cEBDf3D4bBF14812DcCB1ccB20AB26EA547f44',
       WOKB: '0xe538905cf8410324e03a5a23c1c177a474d59b2b',
               PUMPU_ROUTER: '0x95E6739000000000000000000000000000000000', // Pumpu Router 地址（需要确认正确地址）
       PUMPU_FACTORY_ABI: [
         "event Deployed(address indexed addr, uint256 amount)",
         // 注意：如果Factory没有此函数，请不要调用
         "function getDeployedTokens() external view returns (address[] memory)"
       ],
       PUMP_TOKEN_ABI: [
         "function description() external view returns (string memory)",
         "function image() external view returns (string memory)",
         "function website() external view returns (string memory)",
         "function telegram() external view returns (string memory)",
         "function twitter() external view returns (string memory)"
       ],
       ROUTER_ABI: [
         "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)",
         "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)",
         "function WETH() external pure returns (address)",
         "function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
         "function token0() external view returns (address)",
         "function token1() external view returns (address)"
       ]
     };

    // 开盘检测与价格监控配置
    const OPENING_DETECTION_CONFIG = {
      STATUS_CHECK_INTERVAL: 30000, // 30s 检查状态
      PRICE_MONITORING: { UPDATE_INTERVAL: 10000 }, // 10s 更新价格
      OPENING_CONDITIONS: {
        MIN_LIQUIDITY_OKB: 50, // 至少 50 OKB 流动性
        MIN_TRADE_VOLUME: 0, // 无法无后端精确统计，先置 0
        MIN_HOLDER_COUNT: 0, // 无 indexer，先置 0
        MAX_TIME_AFTER_DEPLOY: 0 // 不以时间作为阻断条件
      }
    };

    // 公共 ABI（Pair/Pumpu 扩展）
    const PAIR_ABI = [
      'function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)',
      'function token0() view returns (address)',
      'function token1() view returns (address)'
    ];
    const PUMP_TOKEN_EXT_ABI = [
      'function virtualEth() view returns (uint256)',
      'function virtualToken() view returns (uint256)',
      'function realEth() view returns (uint256)',
      'function realToken() view returns (uint256)'
    ];
    // ERC20 元数据 ABI（用于兜底读取 name/symbol）
    const ERC20_METADATA_ABI = [
      'function name() view returns (string)',
      'function symbol() view returns (string)',
      'function totalSupply() view returns (uint256)',
      'function decimals() view returns (uint8)'
    ];

                   // 全局变量
      let provider, signer, factoryContract;
      let readProvider, factoryReadContract;
      let routerContract;
      let isConnected = false;
      let deployedTokens = [];
      let tokenData = {};
             let monitoredAddresses = new Set();
       let okayMonitoredAddresses = new Set(); // OKAY监控的代币地址
       let statusUpdateInterval;
       let priceUpdateInterval;
              let currentBuyToken = null; // 当前要购买的代币
        let historyRecords = []; // 历史记录数组
      
             // 本地存储键名
       const STORAGE_KEYS = {
         MONITORED_TOKENS: 'pumpu_monitored_tokens',
         OKAY_MONITORED_TOKENS: 'pumpu_okay_monitored_tokens',
         USER_PREFERENCES: 'pumpu_user_preferences',
         TOKEN_HISTORY: 'pumpu_token_history',
         HISTORY_RECORDS: 'pumpu_history_records'
       };
     
     // 用户偏好设置
     let userPreferences = {
       soundEnabled: true,
       notificationEnabled: true,
       autoRefresh: true,
       priceChangeThreshold: 0.1, // 10% 价格变化提醒
       minLiquidityThreshold: 50
     };

                  // 初始化
         async function init() {
           try {
             // 加载本地存储的数据
             loadLocalData();
             
                                            // 从 Firebase 加载代币数据
                console.log('🔄 正在从 Firebase 加载数据...');
                updateSyncStatus('🔄', '加载中...');
                const firebaseData = await loadFromFirebase('pumpu_tokens');
                if (firebaseData) {
                  deployedTokens = firebaseData.tokens || [];
                  tokenData = firebaseData.tokenData || [];
                  monitoredAddresses = new Set(firebaseData.monitoredAddresses || []);
                  console.log(`✅ 从 Firebase 加载了 ${deployedTokens.length} 个代币`);
                  
                  // 更新UI显示
                  updateTokenDisplay();
                  updateSyncStatus('✅', '数据已加载');
                  
                  // 默认显示首页（三个列同时显示）
                  showHome();
                } else {
                  updateSyncStatus('ℹ️', '无历史数据');
                  
                  // 即使没有数据也显示首页
                  showHome();
                }
                
                // 从 Firebase 加载OKAY监控代币数据
                const okayFirebaseData = await loadFromFirebase('pumpu_okay_tokens');
                if (okayFirebaseData && okayFirebaseData.okayMonitoredAddresses) {
                  okayMonitoredAddresses = new Set(okayFirebaseData.okayMonitoredAddresses);
                  console.log(`✅ 从 Firebase 加载了 ${okayMonitoredAddresses.size} 个OKAY监控代币`);
                  updateOkayMonitoringDisplay();
                }
                
                // 加载历史记录
                await loadHistoryRecords();
             
             // 检查是否安装了MetaMask
             // 始终初始化只读Provider，便于未连接钱包也能看到数据
             try {
               readProvider = new ethers.providers.JsonRpcProvider(CONFIG.XLAYER_RPC);
               console.log('使用主RPC端点:', CONFIG.XLAYER_RPC);
             } catch (error) {
               console.warn('主RPC端点失败，尝试备用端点:', error);
               try {
                 readProvider = new ethers.providers.JsonRpcProvider(CONFIG.XLAYER_RPC_BACKUP);
                 console.log('使用备用RPC端点:', CONFIG.XLAYER_RPC_BACKUP);
               } catch (backupError) {
                 console.error('所有RPC端点都失败:', backupError);
                 throw new Error('无法连接到区块链网络');
               }
             }
             factoryReadContract = new ethers.Contract(
               CONFIG.PUMPU_FACTORY,
               CONFIG.PUMPU_FACTORY_ABI,
               readProvider
             );

            if (typeof window.ethereum !== 'undefined') {
              provider = new ethers.providers.Web3Provider(window.ethereum);
              
              // 监听账户变化
              window.ethereum.on('accountsChanged', function (accounts) {
                if (accounts.length === 0) {
                  disconnectWallet();
                } else {
                  updateWalletInfo(accounts[0]);
                }
              });

              // 监听链变化
              window.ethereum.on('chainChanged', function (chainId) {
                if (chainId !== CONFIG.XLAYER_CHAIN_ID_HEX) {
                  console.warn('当前不是XLayer主网，部分功能可能不可用');
                }
              });

              console.log('Web3 provider initialized');
            } else {
              console.log('MetaMask 未安装，将仅使用只读模式');
            }

                 // 无论是否连接钱包，都开始只读监听
             startReadonlyMonitoring();
             
             // 启动状态更新定时器
             startStatusUpdates();
             
             // 启动价格监控
             startPriceMonitoring();
            
                         // 启动后自动尝试回填缺失元数据（延迟执行，避免阻塞）
             setTimeout(() => {
               try { 
                 backfillMissingMeta(); 
                 // 同步代币名称数据
                 syncTokenNames();
               } catch (e) { console.warn('自动回填元数据失败:', e); }
             }, 3000);
           } catch (error) {
             console.error('初始化失败:', error);
           }
         }

    // 连接钱包
    async function connectWallet() {
      try {
        if (!provider) {
          alert('请先安装MetaMask');
          return;
        }

        const accounts = await provider.send("eth_requestAccounts", []);
        if (accounts.length > 0) {
          isConnected = true;
          signer = provider.getSigner();
          updateWalletInfo(accounts[0]);
          
          // 初始化合约
          await initContracts();
          
          // 开始监听（带签名者，仅当需要写操作时）
          startListening();
        }
      } catch (error) {
        console.error('连接钱包失败:', error);
        alert('连接钱包失败: ' + error.message);
      }
    }

    // 断开钱包连接
    function disconnectWallet() {
      isConnected = false;
      signer = null;
      updateWalletInfo(null);
      stopListening();
    }

    // 更新钱包信息显示
    function updateWalletInfo(address) {
      const walletSection = document.getElementById('wallet-section');
      if (address) {
        walletSection.innerHTML = `
          <div class="wallet-info">
            <span class="wallet-address">${address.substring(0, 6)}...${address.substring(38)}</span>
            <button class="connect-wallet" onclick="disconnectWallet()">断开</button>
          </div>
        `;
      } else {
        walletSection.innerHTML = `
          <button class="refresh-btn" onclick="connectWallet()">连接钱包</button>
        `;
      }
    }

         // 初始化合约
     async function initContracts() {
       try {
         factoryContract = new ethers.Contract(
           CONFIG.PUMPU_FACTORY,
           CONFIG.PUMPU_FACTORY_ABI,
           signer
         );
         
         // 初始化 Router 合约
         routerContract = new ethers.Contract(
           CONFIG.PUMPU_ROUTER,
           CONFIG.ROUTER_ABI,
           signer
         );
         
         console.log('合约初始化成功');
       } catch (error) {
         console.error('合约初始化失败:', error);
       }
     }

    // 开始监听新代币
    async function startListening() {
      try {
        // 监听Deployed事件
        factoryContract.on('Deployed', async (addr, amount) => {
          console.log('新代币部署:', addr, amount);
          await addNewToken(addr, amount);
        });

        console.log('开始监听新代币');
      } catch (error) {
        console.error('监听失败:', error);
      }
    }

    // 停止监听
    function stopListening() {
      if (factoryContract) {
        factoryContract.removeAllListeners();
      }
      if (factoryReadContract) {
        factoryReadContract.removeAllListeners();
      }
    }

    // 只读监听 + 回溯最近事件
    async function startReadonlyMonitoring() {
      try {
        if (!factoryReadContract) return;

        // 实时事件
        factoryReadContract.on('Deployed', async (addr, amount) => {
          console.log('[只读] 新代币部署:', addr, amount);
          await addNewToken(addr, amount);
        });

                 // 回溯最近N个区块内的事件（限制在100个区块内）
         const latest = await readProvider.getBlockNumber();
         const lookback = 100; // 限制在100个区块内，避免RPC错误
         const fromBlock = Math.max(0, latest - lookback);
        const filter = factoryReadContract.filters.Deployed();
        const logs = await factoryReadContract.queryFilter(filter, fromBlock, latest);
        for (const log of logs) {
          const addr = log.args && log.args[0];
          const amount = log.args && log.args[1] ? log.args[1] : 0;
          if (addr && !tokenData[addr]) {
            await addNewToken(addr, amount);
          }
        }

        console.log('只读监控已启动，区块:', fromBlock, '→', latest, '事件数:', logs.length);
      } catch (error) {
        console.error('只读监控失败:', error);
      }
    }

    // 添加新代币
    async function addNewToken(address, amount) {
      try {
        const tokenContract = new ethers.Contract(
          address,
          CONFIG.PUMP_TOKEN_ABI,
          readProvider
        );

        // 获取代币信息
        const [description, image, website, telegram, twitter] = await Promise.all([
          tokenContract.description().catch(() => ''),
          tokenContract.image().catch(() => ''),
          tokenContract.website().catch(() => ''),
          tokenContract.telegram().catch(() => ''),
          tokenContract.twitter().catch(() => '')
        ]);

        const tokenInfo = {
          address,
          description,
          image,
          website,
          telegram,
          twitter,
          amount: ethers.utils.formatEther(amount),
          timestamp: Date.now(),
          status: 'new',
          price: 0,
          liquidity: 0,
          holderCount: 0,
          tradeVolume: 0,
          lastStatusUpdate: Date.now()
        };

        // 优先尝试从合约读取真实的名称和符号
        try {
          const erc20Contract = new ethers.Contract(address, ERC20_METADATA_ABI, readProvider);
          const [name, symbol] = await Promise.all([
            erc20Contract.name().catch(() => ''),
            erc20Contract.symbol().catch(() => '')
          ]);
          
          if (name && typeof name === 'string' && name.trim()) {
            tokenInfo.name = name.trim();
          }
          if (symbol && typeof symbol === 'string' && symbol.trim()) {
            tokenInfo.symbol = symbol.trim();
          }
        } catch (e) {
          console.warn('无法从合约读取名称/符号:', e);
        }
        
        // 如果合约中没有名称，才尝试从描述中提取（兜底）
        if (!tokenInfo.name || !tokenInfo.symbol) {
          const metaGuess = extractNameSymbolFromDescription(description);
          if (metaGuess.name && !tokenInfo.name) tokenInfo.name = metaGuess.name;
          if (metaGuess.symbol && !tokenInfo.symbol) tokenInfo.symbol = metaGuess.symbol;
        }

        // 确保两个数据源都包含完整的代币信息
        tokenData[address] = tokenInfo;
        deployedTokens.push(tokenInfo);
        
        // 强制同步名称和符号到两个数据源
        if (tokenInfo.name) {
          tokenData[address].name = tokenInfo.name;
        }
        if (tokenInfo.symbol) {
          tokenData[address].symbol = tokenInfo.symbol;
        }

        // 异步解析 DYOR 代币头像（仅对 DYOR 生效）
        (async () => {
          try {
            if (tokenInfo.source !== 'okay-monitoring') {
              const imgUrl = await resolveDYORTokenImage(address);
              if (imgUrl) {
                tokenData[address].image = imgUrl;
                // 轻量刷新当前列
                updateTokenDisplay();
              }
            }
          } catch (e) {
            console.warn('DYOR 头像解析任务失败:', e);
          }
        })();

        // 更新UI
        updateTokenDisplay();
        
        // 保存到 Firebase
        await saveToFirebase({
          tokens: deployedTokens,
          tokenData: tokenData,
          lastUpdated: Date.now()
        }, 'pumpu_tokens');
        
                 console.log('新代币添加成功:', tokenInfo);
         
         // 添加历史记录
         addHistoryRecord('created', `新代币创建: ${tokenInfo.description || 'Unknown Token'}`, address, {
           amount: tokenInfo.amount,
           description: tokenInfo.description
         });
         
         // 立即检查一次状态
         setTimeout(() => checkTokenStatus(address), 5000);
      } catch (error) {
        console.error('添加新代币失败:', error);
      }
    }

    // 更新代币显示
         function updateTokenDisplay() {
      // 按时间排序
      deployedTokens.sort((a, b) => b.timestamp - a.timestamp);
      
      // 同步代币名称数据
      syncTokenNames();
      
      // 渲染前尝试补全缺失头像与名称/符号（仅 DYOR）
      try {
        deployedTokens.forEach(t => {
          if (t.source !== 'okay-monitoring') {
            if (!t.image) { ensureDYORImage(t.address); }
            if (!t.name || !t.symbol) { ensureDYORMeta(t.address); }
          }
        });
      } catch (e) { console.warn('预解析 DYOR 元信息失败:', e); }
      
      // 更新各列显示（混合两个发射台的代币）
      updateColumnDisplay('new-tokens', deployedTokens.filter(t => t.status === 'new'));
      updateColumnDisplay('pending-tokens', deployedTokens.filter(t => t.status === 'pending'));
      updateColumnDisplay('opened-tokens', deployedTokens.filter(t => t.status === 'opened'));
      updateMonitoringDisplay();
      updateOkayMonitoringDisplay();
    }

         function updateMonitoringDisplay() {
       const tokens = deployedTokens.filter(t => t.isMonitored);
       updateColumnDisplay('monitoring-tokens', tokens);
     }
     
     function updateOkayMonitoringDisplay() {
       const tokens = deployedTokens.filter(t => okayMonitoredAddresses.has(t.address));
       updateColumnDisplay('okay-monitoring-tokens', tokens);
     }

         // 更新列显示
     function updateColumnDisplay(columnId, tokens) {
       const column = document.getElementById(columnId);
       if (tokens.length === 0) {
         column.innerHTML = `
           <h2>${getColumnTitle(columnId)}</h2>
           <div class="loading">暂无数据</div>
         `;
         return;
       }

       let html = `<h2>${getColumnTitle(columnId)}</h2>`;
       
               // 为发射台监控添加统计信息
        if (columnId === 'monitoring-tokens') {
         html += createLaunchpadStats('dyor', tokens);
       } else if (columnId === 'okay-monitoring-tokens') {
         html += createLaunchpadStats('okay', tokens);
       }
       
       tokens.forEach(token => {
         html += createTokenCard(token);
       });
       column.innerHTML = html;
     }

                  // 获取列标题
      function getColumnTitle(columnId) {
        const titles = {
          'new-tokens': '新创建',
          'pending-tokens': '即将打满',
          'opened-tokens': '已开盘',
          'monitoring-tokens': 'DYOR发射台监控',
          'okay-monitoring-tokens': 'OKAY发射台监控',
          'history-tokens': '历史记录'
        };
        return titles[columnId] || '';
      }

         // 创建代币卡片
     function createTokenCard(token) {
       const statusClass = getStatusClass(token.status);
       const statusText = getStatusText(token.status);
       
       // 检查是否是OKAY监控的代币
       const isOkayMonitored = okayMonitoredAddresses.has(token.address);
       
       // 确定发射台类型和样式
       let launchpadBadge = '';
       let launchpadClass = '';
       
       if (isOkayMonitored) {
         launchpadBadge = 'OKAY发射台';
         launchpadClass = 'okay-launchpad';
       } else if (token.source === 'okay-monitoring') {
         launchpadBadge = 'OKAY发射台';
         launchpadClass = 'okay-launchpad';
       } else {
         launchpadBadge = 'DYOR发射台';
         launchpadClass = 'dyor-launchpad';
       }
       
       return `
         <div class="card ${launchpadClass}" onclick="showTokenDetails('${token.address}')">
           <div class="avatar">
             ${(() => { const normalized = normalizeImageUrl(token.image); const avatarUrl = normalized || generateAddressIdenticon(token.address); return `<img src="${avatarUrl}" alt="Logo" onerror="this.style.display='none'; if(this.nextSibling) this.nextSibling.style.display='flex';"><div style=\"display:none;\">${token.description ? token.description.charAt(0).toUpperCase() : 'T'}</div>`; })()}
           </div>
           <div class="info">
             <div class="title">
               <span class="status-indicator ${statusClass}"></span>
               ${token.name || token.symbol || (token.description && !token.description.startsWith('http') ? token.description : 'Unknown Token')}
               ${token.symbol && token.symbol !== token.name ? `<span style=\"margin-left:6px;color:#aaa;font-weight:normal;font-size:12px;\">(${token.symbol})</span>` : ''}
               <span class="launchpad-badge ${launchpadClass}">${launchpadBadge}</span>
             </div>
             <div class="desc">
               ${token.address.substring(0, 8)}...${token.address.substring(36)}<br/>
               创建时间: ${new Date(token.timestamp).toLocaleString()}<br/>
               ${token.amount ? `初始金额: ${token.amount} OKB<br/>` : ''}
               ${token.status === 'opened' ? `价格: ${token.price ? token.price.toFixed(6) + ' OKB' : '获取中...'}<br/>` : ''}
               ${token.status === 'opened' ? `池子OKB: ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : '获取中...'}<br/>` : ''}
               ${token.status === 'opened' ? `市值: ${token.marketCap ? formatMarketCap(token.marketCap) : '获取中...'}` : ''}
               ${token.status === 'pending' ? `即将开盘: 流动性 ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : '获取中...'}<br/>` : ''}
               ${token.status === 'opened' && launchpadClass === 'dyor-launchpad' && token.priceChange !== undefined ? 
                 `<span class="price-change ${token.priceChange >= 0 ? 'positive' : 'negative'}">
                   ${token.priceChange >= 0 ? '+' : ''}${token.priceChange.toFixed(2)}%
                 </span><br/>` : ''
               }
               ${token.status === 'opened' && launchpadClass === 'dyor-launchpad' && token.lastPriceUpdate ? 
                 `更新时间: ${new Date(token.lastPriceUpdate).toLocaleTimeString()}<br/>` : ''
               }
             </div>
           </div>
           <div class="stats">
             ${token.status === 'opened' ? 
               `<div style="margin-bottom: 5px; color: #00ff00;">已开盘</div>` : 
               `<div style="margin-bottom: 5px; color: #ffaa00;">${token.status === 'pending' ? '即将打满' : '新创建'}</div>`
             }
             <span class="buy-btn">查看详情</span>
             ${isOkayMonitored ? `<button class="refresh-btn" onclick="removeFromOkayMonitoring('${token.address}')" style="margin-left: 5px; background: #ff4444;">移除</button>` : ''}
             ${!isOkayMonitored && token.status === 'opened' ? `<button class="refresh-btn" onclick="refreshDYORTokenPrice('${token.address}')" style="margin-left: 5px; background: #00d8ff; font-size: 10px;">刷新价格</button>` : ''}
           </div>
         </div>
       `;
     }

    // 获取状态样式类
    function getStatusClass(status) {
      const classes = {
        'new': 'status-live',
        'pending': 'status-pending',
        'opened': 'status-closed'
      };
      return classes[status] || 'status-pending';
    }

    // 获取状态文本
    function getStatusText(status) {
      const texts = {
        'new': '新创建',
        'pending': '即将打满',
        'opened': '已开盘'
      };
      return texts[status] || '未知';
    }

    // 规范化图片 URL（支持 ipfs://、/ipfs/、裸 CID）
    function normalizeImageUrl(raw) {
      try {
        if (!raw || typeof raw !== 'string') return '';
        const trimmed = raw.trim();
        if (trimmed.startsWith('http://') || trimmed.startsWith('https://') || trimmed.startsWith('data:')) {
          return trimmed;
        }
        const gateway = 'https://ipfs.io/ipfs/';
        if (trimmed.startsWith('ipfs://ipfs/')) {
          return gateway + trimmed.replace('ipfs://ipfs/', '');
        }
        if (trimmed.startsWith('ipfs://')) {
          return gateway + trimmed.replace('ipfs://', '');
        }
        if (trimmed.startsWith('/ipfs/')) {
          return gateway + trimmed.replace('/ipfs/', '');
        }
        // 粗略判断裸 CID（CIDv0 以 Qm 开头，CIDv1 常以 bafy 开头）
        const looksLikeCid = /^Qm[1-9A-Za-z]{44,}|^bafy[1-9A-Za-z]{20,}/.test(trimmed);
        if (looksLikeCid) {
          return gateway + trimmed;
        }
        return trimmed;
      } catch (e) {
        return '';
      }
    }

    // 生成地址 Identicon（SVG base64）
    function generateAddressIdenticon(address) {
      try {
        const seed = (address || '').toString().toLowerCase();
        let hash = 0;
        for (let i = 0; i < seed.length; i++) {
          hash = ((hash << 5) - hash) + seed.charCodeAt(i);
          hash |= 0;
        }
        const hue = Math.abs(hash) % 360;
        const color = `hsl(${hue},70%,50%)`;
        const bg = '#1e1e1e';
        const size = 64;
        const cell = size / 5;
        let rects = '';
        for (let y = 0; y < 5; y++) {
          for (let x = 0; x < 3; x++) {
            const bitIndex = (y * 3 + x) % 31;
            const bit = (hash >> bitIndex) & 1;
            if (bit) {
              const px = x * cell;
              const py = y * cell;
              rects += `<rect x='${px}' y='${py}' width='${cell}' height='${cell}' fill='${color}'/>`;
              const mirrX = (4 - x) * cell;
              rects += `<rect x='${mirrX}' y='${py}' width='${cell}' height='${cell}' fill='${color}'/>`;
            }
          }
        }
        const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'><rect width='100%' height='100%' fill='${bg}'/>${rects}</svg>`;
        return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
      } catch (e) {
        return '';
      }
    }

    // 显示代币详情
    function showTokenDetails(address) {
      // 优先从 deployedTokens 中查找，确保数据一致性
      let token = deployedTokens.find(t => t.address === address);
      if (!token) {
        token = tokenData[address];
      }
      if (!token) return;

      const modal = document.getElementById('tokenModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalDetails = document.getElementById('modalDetails');

      modalTitle.textContent = token.name || token.symbol || (token.description && !token.description.startsWith('http') ? token.description : '代币详情');
      modalDetails.innerHTML = `
        <div class="detail-item">
          <h4>基本信息</h4>
          <p><strong>名称:</strong> ${token.name || '—'}</p>
          <p><strong>符号:</strong> ${token.symbol || '—'}</p>
          <p><strong>简介:</strong> ${token.description && !token.description.startsWith('http') ? token.description : '—'}</p>
          <p><strong>地址:</strong> ${token.address}</p>
          <p><strong>创建时间:</strong> ${new Date(token.timestamp).toLocaleString()}</p>
          <p><strong>初始金额:</strong> ${token.amount} OKB</p>
        </div>
        <div class="detail-item">
          <h4>链接</h4>
          <p><strong>网站:</strong> ${token.website && !token.website.startsWith('http') ? token.website : (token.website ? `<a href="${token.website}" target="_blank">${token.website}</a>` : '无')}</p>
          <p><strong>Telegram:</strong> ${token.telegram ? `<a href="${token.telegram}" target="_blank">${token.telegram}</a>` : '无'}</p>
          <p><strong>Twitter:</strong> ${token.twitter ? `<a href="${token.twitter}" target="_blank">${token.twitter}</a>` : '无'}</p>
        </div>
                 <div class="detail-item">
           <h4>操作</h4>
           <button class="buy-btn" onclick="showBuyInterface('${token.address}')">买入代币</button>
           <button class="refresh-btn" onclick="addToMonitoring('${token.address}')">添加到监控</button>
           ${token.status === 'opened' || token.status === 'pending' ? `<button class="refresh-btn" onclick="showPoolDetails('${token.address}')" style="margin-top: 5px; background: #00d8ff;">查看池子详情</button>` : ''}
         </div>
        <div class="detail-item">
          <h4>市场数据</h4>
          ${token.status === 'opened' ? `
            <p><strong>价格:</strong> ${token.price ? token.price.toFixed(6) + ' OKB' : '获取中...'}</p>
            <p><strong>池子OKB:</strong> ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : '获取中...'}</p>
            <p><strong>市值:</strong> ${token.marketCap ? formatMarketCap(token.marketCap) : '获取中...'}</p>
            <p><strong>总供应量:</strong> ${token.totalSupply ? token.totalSupply.toLocaleString() : '获取中...'}</p>
          ` : token.status === 'pending' ? `
            <p><strong>即将开盘:</strong> <span style="color: #ffaa00;">流动性接近开盘条件</span></p>
            <p><strong>当前流动性:</strong> ${token.liquidity ? token.liquidity.toFixed(2) + ' OKB' : '获取中...'}</p>
            <p><strong>开盘条件:</strong> ${OPENING_DETECTION_CONFIG.OPENING_CONDITIONS.MIN_LIQUIDITY_OKB} OKB</p>
            <p style="color: #ffaa00;">⚠️ 代币即将开盘，请密切关注</p>
          ` : '<p>代币尚未开盘，暂无市场数据</p>'}
        </div>
        <div class="detail-item">
          <h4>状态</h4>
          <p><strong>当前状态:</strong> <span class="status-indicator ${getStatusClass(token.status)}"></span>${getStatusText(token.status)}</p>
          <button class="refresh-btn" onclick="updateTokenStatus('${token.address}')">更新状态</button>
        </div>
      `;

      modal.style.display = 'block';
    }

    // 关闭模态框
    function closeModal() {
      document.getElementById('tokenModal').style.display = 'none';
    }

         // 显示购买界面
     function showBuyInterface(address) {
       if (!isConnected) {
         alert('请先连接钱包');
         return;
       }
       
       currentBuyToken = tokenData[address];
       if (!currentBuyToken) {
         alert('代币信息不存在');
         return;
       }
       
       const buyModal = document.getElementById('buyModal');
       const buyModalTitle = document.getElementById('buyModalTitle');
       const buyModalContent = document.getElementById('buyModalContent');
       
       buyModalTitle.textContent = `购买 ${currentBuyToken.description || '代币'}`;
       
               buyModalContent.innerHTML = `
          <div class="buy-interface">
            <div class="buy-input-group">
              <label>购买金额 (OKB)</label>
              <input type="number" id="buyAmount" placeholder="输入购买金额" min="0.01" step="0.01" value="0.01" oninput="updateBuyPreview()">
            </div>
            
            <div class="buy-input-group">
              <label>滑点容忍度 (%)</label>
              <input type="number" id="slippage" class="slippage-input" value="5" min="0.1" max="50" step="0.1">
            </div>
            
            <div class="buy-preview" id="buyPreview">
              <h4>交易预览</h4>
              <p>请先输入购买金额</p>
            </div>
            
            <div class="buy-actions">
              <button class="buy-confirm-btn" id="confirmBuyBtn" onclick="buyToken()" disabled>确认购买</button>
              <button class="refresh-btn" onclick="closeBuyModal()">取消</button>
            </div>
          </div>
        `;
       
       buyModal.style.display = 'block';
     }
     
     // 关闭购买模态框
     function closeBuyModal() {
       document.getElementById('buyModal').style.display = 'none';
       currentBuyToken = null;
     }
     
     // 更新购买预览
     async function updateBuyPreview() {
       const amountInput = document.getElementById('buyAmount');
       const preview = document.getElementById('buyPreview');
       const confirmBtn = document.getElementById('confirmBuyBtn');
       
       const amount = parseFloat(amountInput.value);
       if (!amount || amount <= 0) {
         preview.innerHTML = '<h4>交易预览</h4><p>请先输入购买金额</p>';
         confirmBtn.disabled = true;
         return;
       }
       
       try {
         // 显示加载状态
         preview.innerHTML = '<h4>交易预览</h4><p>🔄 计算中...</p>';
         
         // 计算预估代币数量
         const estimatedTokens = await calculateEstimatedTokens(amount);
         
         preview.innerHTML = `
           <h4>交易预览</h4>
           <p><strong>支付:</strong> ${amount.toFixed(4)} OKB</p>
           <p><strong>预计获得:</strong> ${estimatedTokens.toFixed(2)} 代币</p>
           <p><strong>滑点:</strong> ${document.getElementById('slippage').value}%</p>
           <p><strong>代币地址:</strong> ${currentBuyToken.address.substring(0, 8)}...${currentBuyToken.address.substring(36)}</p>
         `;
         
         confirmBtn.disabled = false;
       } catch (error) {
         preview.innerHTML = `
           <h4>交易预览</h4>
           <p style="color: #ff4444;">❌ 计算失败: ${error.message}</p>
         `;
         confirmBtn.disabled = true;
       }
     }
     
           // 计算预估代币数量
      async function calculateEstimatedTokens(ethAmount) {
        try {
          if (!routerContract) {
            throw new Error('Router合约未初始化');
          }
          
          const path = [CONFIG.WOKB, currentBuyToken.address];
          const amountIn = ethers.utils.parseEther(ethAmount.toString());
          
          const amounts = await routerContract.getAmountsOut(amountIn, path);
          const tokenAmount = amounts[1];
          
          return parseFloat(ethers.utils.formatUnits(tokenAmount, 18));
        } catch (error) {
          console.error('计算预估代币数量失败:', error);
          throw new Error('无法计算预估数量，请检查代币合约');
        }
      }
      
      // 执行买入代币
      async function buyToken() {
        if (!isConnected || !currentBuyToken || !routerContract) {
          alert('请先连接钱包并选择代币');
          return;
        }
        
        const buyAmountInput = document.getElementById('buyAmount');
        const slippageInput = document.getElementById('slippage');
        const confirmBtn = document.getElementById('confirmBuyBtn');
        
        const buyAmount = parseFloat(buyAmountInput.value);
        const slippage = parseFloat(slippageInput.value);
        
        if (isNaN(buyAmount) || buyAmount <= 0) {
          alert('请输入有效的购买金额');
          return;
        }
        if (isNaN(slippage) || slippage < 0 || slippage > 100) {
          alert('请输入有效的滑点容忍度 (0-100)');
          return;
        }
        
        confirmBtn.disabled = true;
        confirmBtn.textContent = '交易中...';
        
        try {
          const amountIn = ethers.utils.parseEther(buyAmount.toString());
          const path = [CONFIG.WOKB, currentBuyToken.address];
          
          // 预估获得代币数量
          const amounts = await routerContract.getAmountsOut(amountIn, path);
          const amountOutMin = amounts[1];
          
          // 计算滑点后的最小接收数量
          const minAmountOutWithSlippage = amountOutMin.mul(10000 - Math.floor(slippage * 100)).div(10000);
          
          const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20分钟后截止
          
          // 执行交易
          const tx = await routerContract.swapExactETHForTokens(
            minAmountOutWithSlippage,
            path,
            await signer.getAddress(), // 接收代币的地址
            deadline,
            { value: amountIn } // 发送的OKB数量
          );
          
          showNotification(`交易已发送，哈希: ${tx.hash.substring(0, 10)}...`, 'success');
          
          const receipt = await tx.wait();
          
          if (receipt.status === 1) {
            showNotification('✅ 购买成功！', 'success');
            closeBuyModal();
            
            // 更新代币状态
            if (currentBuyToken) {
              currentBuyToken.lastPurchase = {
                amount: buyAmount,
                tokens: parseFloat(ethers.utils.formatUnits(amountOutMin, 18)),
                timestamp: Date.now(),
                txHash: tx.hash
              };
              
              // 添加购买历史记录
              addHistoryRecord('purchase', `购买代币: ${currentBuyToken.description || 'Unknown Token'}`, currentBuyToken.address, {
                amount: buyAmount,
                tokens: parseFloat(ethers.utils.formatUnits(amountOutMin, 18)),
                txHash: tx.hash,
                description: currentBuyToken.description
              });
              
              // 保存到 Firebase
              await saveToFirebase({
                tokens: deployedTokens,
                tokenData: tokenData,
                lastUpdated: Date.now()
              }, 'pumpu_tokens');
            }
          } else {
            showNotification('❌ 购买失败！', 'error');
          }
          
        } catch (error) {
          console.error('购买失败:', error);
          showNotification(`购买失败: ${error.message}`, 'error');
        } finally {
          // 恢复按钮状态
          confirmBtn.disabled = false;
          confirmBtn.textContent = '确认购买';
        }
      }
     
     

                  // 添加到监控列表
         async function addToMonitoring(address) {
           if (!tokenData[address]) { alert('未找到该代币'); return; }
           tokenData[address].isMonitored = true;
           monitoredAddresses.add(address);
           
           // 保存到本地存储
           saveMonitoredTokens();
           
           // 保存到 Firebase
           await saveToFirebase({
             tokens: deployedTokens,
             tokenData: tokenData,
             monitoredAddresses: Array.from(monitoredAddresses),
             lastUpdated: Date.now()
           }, 'pumpu_tokens');
           
                        // 添加监控历史记录
             addHistoryRecord('monitor', `添加到监控: ${tokenData[address].description || 'Unknown Token'}`, address, {
               description: tokenData[address].description
             });
             
             updateTokenDisplay();
             showNotification('已添加到监控列表', 'success');
         }

    // 顶部手动跟踪输入
    async function trackAddressFromTopBar() {
      const inp = document.getElementById('trackAddressInput');
      const addr = (inp?.value || '').trim();
      if (!addr || !addr.startsWith('0x') || addr.length < 10) { alert('请输入有效的合约地址'); return; }
      try {
        if (!tokenData[addr]) {
          // 不知道 amount，则用 0 作为占位
          await addNewToken(addr, ethers.utils.parseEther('0'));
        }
        await addToMonitoring(addr);
        showColumn('monitoring');
        inp.value = '';
      } catch (e) {
        console.error('手动跟踪失败:', e);
        alert('添加失败: ' + (e?.message || e));
      }
    }

    // 更新代币状态
    async function updateTokenStatus(address) {
      // 这里可以实现状态更新逻辑
      alert('状态更新功能开发中...');
    }

    // 搜索代币
    function searchTokens(query) {
      if (!query) {
        updateTokenDisplay();
        return;
      }

      const filtered = deployedTokens.filter(token => 
        token.description?.toLowerCase().includes(query.toLowerCase()) ||
        token.address.toLowerCase().includes(query.toLowerCase())
      );

      // 更新显示
      updateColumnDisplay('new-tokens', filtered.filter(t => t.status === 'new'));
      updateColumnDisplay('pending-tokens', filtered.filter(t => t.status === 'pending'));
      updateColumnDisplay('opened-tokens', filtered.filter(t => t.status === 'opened'));
    }

         // 显示首页（同时显示三个列）
     function showHome() {
       const sections = ['new', 'pending', 'opened'];
       const idMap = { new: 'new-tokens', pending: 'pending-tokens', opened: 'opened-tokens' };
       sections.forEach(s => {
         const el = document.getElementById(idMap[s]);
         if (el) el.style.display = 'block';
       });
       
       // 隐藏监控列表和历史记录
       const monitoringEl = document.getElementById('monitoring-tokens');
       const historyEl = document.getElementById('history-tokens');
       if (monitoringEl) monitoringEl.style.display = 'none';
       if (historyEl) historyEl.style.display = 'none';
       
       // 更新监控列表显示（但不显示）
       updateMonitoringDisplay();
       
       // 高亮首页菜单项
       highlightMenu('home');
     }

         // 更新面包屑导航
     function updateBreadcrumb(pageType) {
       const breadcrumb = document.getElementById('current-page');
       if (breadcrumb) {
         if (pageType === 'home') {
           breadcrumb.innerHTML = '🏠 首页 - 监控概览';
         } else if (pageType === 'monitoring') {
           breadcrumb.innerHTML = '🚀 DYOR发射台监控 - 详细列表';
         } else if (pageType === 'okay-monitoring') {
           breadcrumb.innerHTML = '🚀 OKAY发射台监控 - 详细列表';
         } else {
           const title = getColumnTitle(pageType + '-tokens');
           breadcrumb.innerHTML = `📊 ${title} - 详细列表`;
         }
       }
     }

         // 高亮菜单项
     function highlightMenu(activeType) {
       const menuItems = document.querySelectorAll('.menu a');
       menuItems.forEach(item => {
         // 移除所有高亮样式
         item.style.color = '#fff';
         item.style.fontWeight = 'normal';
         item.style.borderBottom = 'none';
         
         // 高亮当前选中的菜单项
         if (activeType === 'home' && item.textContent.includes('首页')) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         } else if (activeType === 'monitoring' && item.textContent.includes('DYOR发射台')) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         } else if (activeType === 'okay-monitoring' && item.textContent.includes('OKAY发射台')) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         } else if (item.textContent.includes(getColumnTitle(activeType + '-tokens'))) {
           item.style.color = '#00d8ff';
           item.style.fontWeight = 'bold';
           item.style.borderBottom = '2px solid #00d8ff';
         }
       });
       
       // 更新面包屑导航
       updateBreadcrumb(activeType);
     }

                   // 显示指定列
      function showColumn(type) {
        const sections = ['new', 'pending', 'opened', 'monitoring', 'okay-monitoring', 'history'];
        const idMap = { 
          new: 'new-tokens', 
          pending: 'pending-tokens', 
          opened: 'opened-tokens', 
          monitoring: 'monitoring-tokens',
          'okay-monitoring': 'okay-monitoring-tokens',
          history: 'history-tokens'
        };
        sections.forEach(s => {
          const el = document.getElementById(idMap[s]);
          if (el) el.style.display = (s === type ? 'block' : 'none');
        });
        if (type === 'monitoring') updateMonitoringDisplay();
        if (type === 'okay-monitoring') updateOkayMonitoringDisplay();
        if (type === 'history') updateHistoryDisplay();
        
        // 高亮对应菜单项
        highlightMenu(type);
      }

    // 刷新函数
    function refreshNewTokens() {
      if (isConnected) {
        loadDeployedTokens();
      }
    }

    function refreshPendingTokens() {
      // 刷新即将打满的代币
      console.log('刷新即将打满的代币');
    }

    function refreshOpenedTokens() {
      // 刷新已开盘的代币
      console.log('刷新已开盘的代币');
    }

                   function refreshMonitoringTokens() {
        updateMonitoringDisplay();
      }
      
      function refreshOkayMonitoringTokens() {
        updateOkayMonitoringDisplay();
      }
     
     // 刷新历史记录
     function refreshHistoryTokens() {
       updateHistoryDisplay();
     }
     
     // 清空历史记录
     function clearHistory() {
       if (confirm('确定要清空所有历史记录吗？此操作不可恢复。')) {
         historyRecords = [];
         localStorage.removeItem(STORAGE_KEYS.HISTORY_RECORDS);
         saveHistoryToFirebase();
         updateHistoryDisplay();
         showNotification('历史记录已清空', 'success');
       }
     }
     
     // 过滤历史记录
     function filterHistory() {
       updateHistoryDisplay();
     }
     
     // 更新历史记录显示
     function updateHistoryDisplay() {
       const column = document.getElementById('history-tokens');
       if (!column) return;
       
       const typeFilter = document.getElementById('historyTypeFilter')?.value || 'all';
       const dateFilter = document.getElementById('historyDateFilter')?.value;
       
       let filteredRecords = [...historyRecords];
       
       // 按类型过滤
       if (typeFilter !== 'all') {
         filteredRecords = filteredRecords.filter(record => record.type === typeFilter);
       }
       
       // 按日期过滤
       if (dateFilter) {
         const filterDate = new Date(dateFilter);
         filterDate.setHours(0, 0, 0, 0);
         const nextDay = new Date(filterDate);
         nextDay.setDate(nextDay.getDate() + 1);
         
         filteredRecords = filteredRecords.filter(record => {
           const recordDate = new Date(record.timestamp);
           return recordDate >= filterDate && recordDate < nextDay;
         });
       }
       
       if (filteredRecords.length === 0) {
         column.innerHTML = `
           <h2>历史记录
             <button class="refresh-btn" onclick="refreshHistoryTokens()">刷新</button>
             <button class="refresh-btn" onclick="clearHistory()" style="margin-left: 5px; background: #ff4444;">清空</button>
           </h2>
           <div class="history-filters">
             <select id="historyTypeFilter" onchange="filterHistory()">
               <option value="all">全部记录</option>
               <option value="created">代币创建</option>
               <option value="status_change">状态变化</option>
               <option value="purchase">购买记录</option>
               <option value="monitor">监控操作</option>
             </select>
             <input type="date" id="historyDateFilter" onchange="filterHistory()" style="margin-left: 10px;">
           </div>
           <div class="loading">暂无历史记录</div>
         `;
         return;
       }
       
       let html = `
         <h2>历史记录
           <button class="refresh-btn" onclick="refreshHistoryTokens()">刷新</button>
           <button class="refresh-btn" onclick="clearHistory()" style="margin-left: 5px; background: #ff4444;">清空</button>
         </h2>
         <div class="history-filters">
           <select id="historyTypeFilter" onchange="filterHistory()">
             <option value="all" ${typeFilter === 'all' ? 'selected' : ''}>全部记录</option>
             <option value="created" ${typeFilter === 'created' ? 'selected' : ''}>代币创建</option>
             <option value="status_change" ${typeFilter === 'status_change' ? 'selected' : ''}>状态变化</option>
             <option value="purchase" ${typeFilter === 'purchase' ? 'selected' : ''}>购买记录</option>
             <option value="monitor" ${typeFilter === 'monitor' ? 'selected' : ''}>监控操作</option>
           </select>
           <input type="date" id="historyDateFilter" onchange="filterHistory()" style="margin-left: 10px;" value="${dateFilter || ''}">
         </div>
       `;
       
       filteredRecords.forEach(record => {
         const recordDate = new Date(record.timestamp);
         const timeAgo = getTimeAgo(record.timestamp);
         
         html += `
           <div class="history-item ${record.type}">
             <div class="time">${timeAgo}</div>
             <div class="type">${getHistoryTypeText(record.type)}</div>
             <div class="content">
               ${record.content}
               ${record.tokenAddress ? `<br><span class="token-address">${record.tokenAddress}</span>` : ''}
               ${record.extraData ? formatExtraData(record.extraData) : ''}
             </div>
           </div>
         `;
       });
       
       column.innerHTML = html;
     }
     
     // 获取时间差描述
     function getTimeAgo(timestamp) {
       const now = Date.now();
       const diff = now - timestamp;
       
       const minutes = Math.floor(diff / 60000);
       const hours = Math.floor(diff / 3600000);
       const days = Math.floor(diff / 86400000);
       
       if (minutes < 1) return '刚刚';
       if (minutes < 60) return `${minutes}分钟前`;
       if (hours < 24) return `${hours}小时前`;
       if (days < 7) return `${days}天前`;
       
       return new Date(timestamp).toLocaleDateString();
     }
     
     // 获取历史记录类型文本
     function getHistoryTypeText(type) {
       const texts = {
         'created': '创建',
         'status_change': '状态变化',
         'purchase': '购买',
         'monitor': '监控'
       };
       return texts[type] || '未知';
     }
     
     // 格式化额外数据
     function formatExtraData(extraData) {
       let result = '';
       if (extraData.amount) result += `<br>金额: ${extraData.amount} OKB`;
       if (extraData.tokens) result += `<br>代币: ${extraData.tokens.toFixed(2)}`;
       if (extraData.txHash) result += `<br>交易: ${extraData.txHash.substring(0, 10)}...`;
       if (extraData.oldStatus && extraData.newStatus) {
         result += `<br>状态: ${getStatusText(extraData.oldStatus)} → ${getStatusText(extraData.newStatus)}`;
       }
       return result;
     }

    // 启动状态更新定时器
    function startStatusUpdates() {
      // 每30秒检查一次代币状态
      statusUpdateInterval = setInterval(() => {
        deployedTokens.forEach(token => {
          if (token.status !== 'opened') {
            checkTokenStatus(token.address);
          }
        });
      }, OPENING_DETECTION_CONFIG.STATUS_CHECK_INTERVAL);

      // 每10秒更新一次价格
      priceUpdateInterval = setInterval(() => {
        deployedTokens.forEach(token => {
          if (token.status === 'opened') {
            updateTokenPrice(token.address);
          }
        });
      }, OPENING_DETECTION_CONFIG.PRICE_MONITORING.UPDATE_INTERVAL);
    }

    // 检查代币状态
    async function checkTokenStatus(address) {
      try {
        const token = tokenData[address];
        if (!token) return;

        // 检查是否满足开盘条件
        const isOpened = await checkOpeningConditions(address);
        
        if (isOpened && token.status !== 'opened') {
                     token.status = 'opened';
           token.lastStatusUpdate = Date.now();
           console.log(`代币 ${token.description || address} 已开盘！`);
           
           // 添加历史记录
           addHistoryRecord('status_change', `代币开盘: ${token.description || 'Unknown Token'}`, address, {
             oldStatus: 'pending',
             newStatus: 'opened',
             description: token.description
           });
           
           // 更新UI
           updateTokenDisplay();
           
           // 保存到 Firebase
           await saveToFirebase({
             tokens: deployedTokens,
             tokenData: tokenData,
             lastUpdated: Date.now()
           }, 'pumpu_tokens');
           
           // 显示开盘通知
           showOpeningNotification(token);
        } else if (!isOpened && token.status === 'new') {
          // 检查是否即将打满
          const isPending = await checkPendingConditions(address);
                     if (isPending) {
             token.status = 'pending';
             token.lastStatusUpdate = Date.now();
             
             // 添加历史记录
             addHistoryRecord('status_change', `代币即将打满: ${token.description || 'Unknown Token'}`, address, {
               oldStatus: 'new',
               newStatus: 'pending',
               description: token.description
             });
             
             updateTokenDisplay();
             
             // 保存到 Firebase
             await saveToFirebase({
               tokens: deployedTokens,
               tokenData: tokenData,
               lastUpdated: Date.now()
             }, 'pumpu_tokens');
           }
        }
      } catch (error) {
        console.error(`检查代币状态失败 ${address}:`, error);
      }
    }

    // 检查开盘条件
    async function checkOpeningConditions(address) {
      try {
        const conditions = OPENING_DETECTION_CONFIG.OPENING_CONDITIONS;

        // 优先尝试按 UniswapV2 Pair 读取储备（Pumpu 下地址即为池子地址）
        let liquidityOkb = 0;
        let priceOkb = 0;
        try {
          const pair = new ethers.Contract(address, PAIR_ABI, readProvider);
          const [reserve0, reserve1] = await pair.getReserves();
          const [t0, t1] = await Promise.all([
            pair.token0(),
            pair.token1()
          ]);
          const wokbLower = CONFIG.WOKB.toLowerCase();
          if (t0.toLowerCase() === wokbLower) {
            liquidityOkb = Number(ethers.utils.formatEther(reserve0));
            if (reserve1.gt(0)) {
              priceOkb = Number(ethers.utils.formatEther(reserve0)) / Number(ethers.utils.formatEther(reserve1));
            }
          } else if (t1.toLowerCase() === wokbLower) {
            liquidityOkb = Number(ethers.utils.formatEther(reserve1));
            if (reserve0.gt(0)) {
              priceOkb = Number(ethers.utils.formatEther(reserve1)) / Number(ethers.utils.formatEther(reserve0));
            }
          }
        } catch (_) {
                     // 不属于标准 Pair，则尝试 Pumpu 虚拟/真实储备
           try {
             const pump = new ethers.Contract(address, PUMP_TOKEN_EXT_ABI, readProvider);
             const [vEth, vTok, rEth, rTok] = await Promise.all([
               pump.virtualEth().catch(() => ethers.constants.Zero),
               pump.virtualToken().catch(() => ethers.constants.Zero),
               pump.realEth().catch(() => ethers.constants.Zero),
               pump.realToken().catch(() => ethers.constants.Zero)
             ]);
             
             // 虚拟储备 + 真实储备 = 总储备
             const totalEth = vEth.add(rEth);
             liquidityOkb = Number(ethers.utils.formatEther(totalEth));
             
             if (vTok.gt(0) || rTok.gt(0)) {
               const totalTok = vTok.add(rTok);
               priceOkb = Number(ethers.utils.formatEther(totalEth)) / Number(ethers.utils.formatEther(totalTok));
             }
           } catch (__) {}
        }

        tokenData[address].liquidity = liquidityOkb;
        tokenData[address].price = priceOkb;
        
        // 获取代币总供应量和计算市值
        try {
          const tokenContract = new ethers.Contract(address, ERC20_METADATA_ABI, readProvider);
          const [supply, decimals] = await Promise.all([
            tokenContract.totalSupply(),
            tokenContract.decimals()
          ]);
          
          const totalSupply = parseFloat(ethers.utils.formatUnits(supply, decimals));
          tokenData[address].totalSupply = totalSupply;
          
          // 计算市值：总供应量 × 价格
          if (priceOkb > 0 && totalSupply > 0) {
            tokenData[address].marketCap = totalSupply * priceOkb;
          } else {
            tokenData[address].marketCap = 0;
          }
        } catch (capError) {
          console.warn('无法获取市值信息:', capError);
          tokenData[address].totalSupply = 0;
          tokenData[address].marketCap = 0;
        }
        
        // 无 indexer 情况下，holderCount 与 tradeVolume 暂置 0
        tokenData[address].holderCount = 0;
        tokenData[address].tradeVolume = 0;

        return (
          liquidityOkb >= conditions.MIN_LIQUIDITY_OKB &&
          0 >= conditions.MIN_TRADE_VOLUME &&
          0 >= conditions.MIN_HOLDER_COUNT
        );
      } catch (error) {
        console.error(`检查开盘条件失败 ${address}:`, error);
        return false;
      }
    }

    // 检查即将打满条件
    async function checkPendingConditions(address) {
      try {
        const token = tokenData[address];
        
        // 检查流动性是否接近开盘条件（比如达到80%以上）
        const conditions = OPENING_DETECTION_CONFIG.OPENING_CONDITIONS;
        const minLiquidity = conditions.MIN_LIQUIDITY_OKB;
        
        // 获取当前流动性
        let currentLiquidity = 0;
        try {
          // 优先尝试按 UniswapV2 Pair 读取储备
          const pair = new ethers.Contract(address, PAIR_ABI, readProvider);
          const [reserve0, reserve1] = await pair.getReserves();
          const [t0, t1] = await Promise.all([
            pair.token0(),
            pair.token1()
          ]);
          const wokbLower = CONFIG.WOKB.toLowerCase();
          if (t0.toLowerCase() === wokbLower) {
            currentLiquidity = Number(ethers.utils.formatEther(reserve0));
          } else if (t1.toLowerCase() === wokbLower) {
            currentLiquidity = Number(ethers.utils.formatEther(reserve1));
          }
        } catch (_) {
          // 尝试 Pumpu 虚拟储备
          try {
            const pump = new ethers.Contract(address, PUMP_TOKEN_EXT_ABI, readProvider);
            const [vEth, vTok, rEth, rTok] = await Promise.all([
              pump.virtualEth().catch(() => ethers.constants.Zero),
              pump.virtualToken().catch(() => ethers.constants.Zero),
              pump.realEth().catch(() => ethers.constants.Zero),
              pump.realToken().catch(() => ethers.constants.Zero)
            ]);
            
            const totalEth = vEth.add(rEth);
            currentLiquidity = Number(ethers.utils.formatEther(totalEth));
          } catch (__) {}
        }
        
        // 如果流动性达到开盘条件的80%以上，标记为即将打满
        const liquidityThreshold = minLiquidity * 0.8; // 80%的开盘条件
        return currentLiquidity >= liquidityThreshold && currentLiquidity < minLiquidity;
        
      } catch (error) {
        console.error(`检查即将打满条件失败 ${address}:`, error);
        return false;
      }
    }

    // 更新代币价格
    async function updateTokenPrice(address) {
      try {
        const token = tokenData[address];
        if (!token) return;
        let priceOkb = token.price || 0;
        // 再次按储备计算价格
        try {
          const pair = new ethers.Contract(address, PAIR_ABI, readProvider);
          const [reserve0, reserve1] = await pair.getReserves();
          const [t0, t1] = await Promise.all([pair.token0(), pair.token1()]);
          const wokbLower = CONFIG.WOKB.toLowerCase();
          if (t0.toLowerCase() === wokbLower && reserve1.gt(0)) {
            priceOkb = Number(ethers.utils.formatEther(reserve0)) / Number(ethers.utils.formatEther(reserve1));
          } else if (t1.toLowerCase() === wokbLower && reserve0.gt(0)) {
            priceOkb = Number(ethers.utils.formatEther(reserve1)) / Number(ethers.utils.formatEther(reserve0));
          }
                 } catch (_) {
           try {
             const pump = new ethers.Contract(address, PUMP_TOKEN_EXT_ABI, readProvider);
             const [vEth, vTok, rEth, rTok] = await Promise.all([
               pump.virtualEth().catch(() => ethers.constants.Zero),
               pump.virtualToken().catch(() => ethers.constants.Zero),
               pump.realEth().catch(() => ethers.constants.Zero),
               pump.realToken().catch(() => ethers.constants.Zero)
             ]);
             
             if (vTok.gt(0) || rTok.gt(0)) {
               const totalEth = vEth.add(rEth);
               const totalTok = vTok.add(rTok);
               priceOkb = Number(ethers.utils.formatEther(totalEth)) / Number(ethers.utils.formatEther(totalTok));
             }
           } catch (__) {}
         }
        token.price = priceOkb;
        
        // 更新市值
        if (token.totalSupply && token.totalSupply > 0 && priceOkb > 0) {
          token.marketCap = token.totalSupply * priceOkb;
        }
        
        updateTokenPriceDisplay(address);
      } catch (error) {
        console.error(`更新代币价格失败 ${address}:`, error);
      }
    }

    // 更新代币价格显示
    function updateTokenPriceDisplay(address) {
      // 简化：重新渲染卡片区域aa
      updateTokenDisplay();
    }

    // 显示开盘通知
    function showOpeningNotification(token) {
      // 创建开盘通知
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #00ff00;
        color: #000;
        padding: 15px;
        border-radius: 8px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,255,0,0.3);
        animation: slideIn 0.5s ease;
      `;
      
      notification.innerHTML = `
        <h4>🚀 代币已开盘！</h4>
        <p><strong>${token.description || 'Unknown Token'}</strong></p>
        <p>地址: ${token.address.substring(0, 8)}...${token.address.substring(36)}</p>
        <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 10px;">关闭</button>
      `;
      
      document.body.appendChild(notification);
      
      // 5秒后自动消失
      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, 5000);
    }

            // 页面加载完成后初始化
        window.addEventListener('load', init);

        // 页面卸载时清理定时器
        window.addEventListener('beforeunload', () => {
          if (statusUpdateInterval) clearInterval(statusUpdateInterval);
          if (priceUpdateInterval) clearInterval(priceUpdateInterval);
        });

                         // 点击模态框外部关闭
         window.onclick = function(event) {
           const tokenModal = document.getElementById('tokenModal');
           const buyModal = document.getElementById('buyModal');
           
           if (event.target === tokenModal) {
             tokenModal.style.display = 'none';
           }
           
           if (event.target === buyModal) {
             closeBuyModal();
           }
         }

                 // 添加CSS动画
         const style = document.createElement('style');
         style.textContent = `
           @keyframes slideIn {
             from { transform: translateX(100%); opacity: 0; }
             to { transform: translateX(0); opacity: 1; }
           }
           
           @keyframes fadeIn {
             from { opacity: 0; }
             to { opacity: 1; }
           }
           
           .notification {
             position: fixed;
             top: 20px;
             right: 20px;
             padding: 15px 20px;
             border-radius: 8px;
             color: #fff;
             font-weight: bold;
             z-index: 10000;
             animation: slideIn 0.5s ease;
             max-width: 300px;
           }
           
           .notification.success {
             background: #00ff00;
             color: #000;
           }
           
           .notification.warning {
             background: #ffaa00;
             color: #000;
           }
           
           .notification.error {
             background: #ff4444;
           }
           
           .notification.info {
             background: #00d8ff;
             color: #000;
           }
           
           .settings-panel {
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background: #1e1e1e;
             padding: 20px;
             border-radius: 8px;
             border: 1px solid #2c2c2c;
             z-index: 10001;
             display: none;
             min-width: 400px;
           }
           
           .settings-panel h3 {
             margin-bottom: 20px;
             color: #00d8ff;
           }
           
           .setting-item {
             margin-bottom: 15px;
             display: flex;
             justify-content: space-between;
             align-items: center;
           }
           
           .setting-item label {
             color: #fff;
           }
           
           .setting-item input[type="checkbox"] {
             width: 20px;
             height: 20px;
           }
           
                .setting-item input[type="number"] {
       width: 80px;
       padding: 5px;
       background: #2c2c2c;
       border: 1px solid #444;
       color: #fff;
       border-radius: 4px;
     }
     
           /* 购买界面样式 */
      .buy-interface {
        padding: 25px 0;
      }
      
      .buy-input-group {
        margin-bottom: 25px;
      }
     
     .buy-input-group label {
       display: block;
       margin-bottom: 8px;
       color: #00d8ff;
       font-weight: bold;
     }
     
     .buy-input-group input {
       width: 100%;
       padding: 12px;
       background: #2c2c2c;
       border: 1px solid #444;
       color: #fff;
       border-radius: 6px;
       font-size: 16px;
     }
     
     .buy-input-group input:focus {
       outline: none;
       border-color: #00d8ff;
       box-shadow: 0 0 0 2px rgba(0, 216, 255, 0.2);
     }
     
     .buy-preview {
       background: #2c2c2c;
       padding: 15px;
       border-radius: 6px;
       margin-bottom: 20px;
       border-left: 4px solid #00d8ff;
     }
     
     .buy-preview h4 {
       color: #00d8ff;
       margin-bottom: 10px;
     }
     
     .buy-preview p {
       margin: 5px 0;
       color: #ccc;
     }
     
     .buy-actions {
       display: flex;
       gap: 10px;
       justify-content: center;
     }
     
     .buy-confirm-btn {
       background: #00ff00;
       color: #000;
       padding: 12px 24px;
       border: none;
       border-radius: 6px;
       font-size: 16px;
       font-weight: bold;
       cursor: pointer;
       transition: all 0.3s ease;
     }
     
     .buy-confirm-btn:hover {
       background: #00cc00;
       transform: translateY(-2px);
     }
     
     .buy-confirm-btn:disabled {
       background: #666;
       cursor: not-allowed;
       transform: none;
     }
     
     .slippage-input {
       width: 80px !important;
       text-align: center;
     }
     
     /* 历史记录样式 */
     .history-filters {
       margin-bottom: 15px;
       padding: 10px;
       background: #2c2c2c;
       border-radius: 6px;
       display: flex;
       align-items: center;
       gap: 10px;
     }
     
     .history-filters select,
     .history-filters input {
       background: #1e1e1e;
       border: 1px solid #444;
       color: #fff;
       padding: 5px 8px;
       border-radius: 4px;
       font-size: 12px;
     }
     
     .history-item {
       background: #2c2c2c;
       border-radius: 6px;
       padding: 12px;
       margin-bottom: 10px;
       border-left: 4px solid #00d8ff;
       position: relative;
     }
     
     .history-item.created { border-left-color: #00ff00; }
     .history-item.status_change { border-left-color: #ffaa00; }
     .history-item.purchase { border-left-color: #00d8ff; }
     .history-item.monitor { border-left-color: #ff00ff; }
     
     .history-item .time {
       position: absolute;
       top: 8px;
       right: 12px;
       font-size: 11px;
       color: #888;
     }
     
     .history-item .type {
       display: inline-block;
       padding: 2px 6px;
       border-radius: 3px;
       font-size: 10px;
       font-weight: bold;
       margin-bottom: 5px;
     }
     
     .history-item.created .type { background: #00ff00; color: #000; }
     .history-item.status_change .type { background: #ffaa00; color: #000; }
     .history-item.purchase .type { background: #00d8ff; color: #000; }
     .history-item.monitor .type { background: #ff00ff; color: #000; }
     
     .history-item .content {
       color: #ccc;
       font-size: 13px;
       line-height: 1.4;
     }
     
     .history-item .token-address {
       font-family: monospace;
       background: #1e1e1e;
       padding: 2px 4px;
       border-radius: 3px;
       font-size: 11px;
     }
         `;
         document.head.appendChild(style);
         
         // Firebase 数据存储和读取功能
         async function saveToFirebase(data, path) {
           try {
             await database.ref(path).set(data);
             console.log(`✅ 数据已保存到 Firebase: ${path}`);
           } catch (error) {
             console.error(`❌ 保存到 Firebase 失败: ${path}`, error);
           }
         }

         async function loadFromFirebase(path) {
           try {
             const snapshot = await database.ref(path).once('value');
             const data = snapshot.val();
             console.log(`✅ 从 Firebase 加载数据: ${path}`, data);
             return data;
           } catch (error) {
             console.error(`❌ 从 Firebase 加载失败: ${path}`, error);
             return null;
           }
         }

                   // 本地存储功能（作为备用）
                     function loadLocalData() {
             try {
               // 加载监控的代币
               const savedMonitored = localStorage.getItem(STORAGE_KEYS.MONITORED_TOKENS);
               if (savedMonitored) {
                 const addresses = JSON.parse(savedMonitored);
                 monitoredAddresses = new Set(addresses);
                 console.log('已加载本地监控代币:', addresses.length, '个');
               }
               
               // 加载OKAY监控的代币
               const savedOkayMonitored = localStorage.getItem(STORAGE_KEYS.OKAY_MONITORED_TOKENS);
               if (savedOkayMonitored) {
                 const addresses = JSON.parse(savedOkayMonitored);
                 okayMonitoredAddresses = new Set(addresses);
                 console.log('已加载本地OKAY监控代币:', addresses.length, '个');
               }
               
               // 加载用户偏好
               const savedPrefs = localStorage.getItem(STORAGE_KEYS.USER_PREFERENCES);
               if (savedPrefs) {
                 userPreferences = { ...userPreferences, ...JSON.parse(savedPrefs) };
                 console.log('已加载本地用户偏好设置');
               }
               
               // 加载历史记录
               const savedHistory = localStorage.getItem(STORAGE_KEYS.HISTORY_RECORDS);
               if (savedHistory) {
                 historyRecords = JSON.parse(savedHistory);
                 console.log('已加载本地历史记录:', historyRecords.length, '条');
               }
             } catch (error) {
               console.error('加载本地数据失败:', error);
             }
           }
         
         function saveMonitoredTokens() {
           try {
             localStorage.setItem(STORAGE_KEYS.MONITORED_TOKENS, JSON.stringify([...monitoredAddresses]));
           } catch (error) {
             console.error('保存监控代币失败:', error);
           }
         }
         
         function saveOkayMonitoredTokens() {
           try {
             localStorage.setItem(STORAGE_KEYS.OKAY_MONITORED_TOKENS, JSON.stringify([...okayMonitoredAddresses]));
           } catch (error) {
             console.error('保存OKAY监控代币失败:', error);
           }
         }
         
         function saveUserPreferences() {
           try {
             localStorage.setItem(STORAGE_KEYS.USER_PREFERENCES, JSON.stringify(userPreferences));
           } catch (error) {
             console.error('保存用户偏好失败:', error);
           }
         }
         
         function saveTokenHistory() {
           try {
             const history = {
               tokens: deployedTokens,
               tokenData: tokenData,
               timestamp: Date.now()
             };
             localStorage.setItem(STORAGE_KEYS.TOKEN_HISTORY, JSON.stringify(history));
           } catch (error) {
             console.error('保存代币历史失败:', error);
           }
         }
         
                   // 添加历史记录
          function addHistoryRecord(type, content, tokenAddress = null, extraData = {}) {
            const record = {
              id: Date.now() + Math.random(),
              type: type,
              content: content,
              tokenAddress: tokenAddress,
              timestamp: Date.now(),
              ...extraData
            };
            
            historyRecords.unshift(record); // 添加到开头
            
            // 限制历史记录数量（最多1000条）
            if (historyRecords.length > 1000) {
              historyRecords = historyRecords.slice(0, 1000);
            }
            
            // 保存到本地存储
            try {
              localStorage.setItem(STORAGE_KEYS.HISTORY_RECORDS, JSON.stringify(historyRecords));
            } catch (error) {
              console.error('保存历史记录失败:', error);
            }
            
            // 保存到 Firebase
            saveHistoryToFirebase();
            
            console.log('📚 添加历史记录:', record);
          }
          
          // 保存历史记录到 Firebase
          async function saveHistoryToFirebase() {
            try {
              await saveToFirebase({
                historyRecords: historyRecords,
                lastUpdated: Date.now()
              }, 'pumpu_history');
            } catch (error) {
              console.error('保存历史记录到 Firebase 失败:', error);
            }
          }
          
          // 加载历史记录
          async function loadHistoryRecords() {
            try {
              const firebaseHistory = await loadFromFirebase('pumpu_history');
              if (firebaseHistory && firebaseHistory.historyRecords) {
                historyRecords = firebaseHistory.historyRecords;
                console.log(`✅ 从 Firebase 加载了 ${historyRecords.length} 条历史记录`);
              }
            } catch (error) {
              console.error('加载历史记录失败:', error);
            }
          }
          
                 // OKAY监控相关函数
       async function addOkayToken() {
         const address = prompt('请输入代币合约地址:');
         if (!address || !address.startsWith('0x')) {
           alert('请输入有效的合约地址');
           return;
         }
         
         try {
           // 检查是否已经在监控中
           if (okayMonitoredAddresses.has(address)) {
             alert('该代币已在OKAY监控列表中');
             return;
           }
           
           // 从Token合约获取代币信息
           const tokenInfo = await getTokenInfoFromContract(address);
           if (tokenInfo) {
             // 添加到OKAY监控列表
             okayMonitoredAddresses.add(address);
             
             // 保存到本地存储
             saveOkayMonitoredTokens();
             
             // 保存到Firebase
             await saveToFirebase({
               okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // 更新显示
             updateOkayMonitoringDisplay();
             
             // 添加历史记录
             addHistoryRecord('monitor', `添加到OKAY监控: ${tokenInfo.name || 'Unknown Token'}`, address, {
               description: tokenInfo.name,
               symbol: tokenInfo.symbol,
               image: tokenInfo.image
             });
             
             showNotification(`已添加到OKAY监控: ${tokenInfo.name}`, 'success');
           }
         } catch (error) {
           console.error('添加OKAY监控代币失败:', error);
           alert('添加失败: ' + error.message);
         }
       }
       
       // 从Token合约获取代币信息
       async function getTokenInfoFromContract(address) {
         try {
           // Token合约ABI，包含uri()函数
           const TOKEN_ABI = [
             "function uri() external view returns (string calldata)"
           ];
           
           const tokenContract = new ethers.Contract(address, TOKEN_ABI, readProvider);
           
           // 调用uri()函数获取IPFS URL
           const uri = await tokenContract.uri();
           console.log('获取到Token URI:', uri);
           
           if (!uri || uri === '') {
             throw new Error('Token URI为空');
           }
           
           // 解析IPFS URL
           let ipfsUrl = uri;
           if (uri.startsWith('ipfs://')) {
             // 尝试多个IPFS网关
             const ipfsGateways = [
               'https://newgame.mypinata.cloud/ipfs/',
               'https://ipfs.io/ipfs/',
               'https://gateway.pinata.cloud/ipfs/',
               'https://cloudflare-ipfs.com/ipfs/'
             ];
             
             // 尝试第一个网关
             ipfsUrl = uri.replace('ipfs://', ipfsGateways[0]);
           } else if (uri.startsWith('http')) {
             ipfsUrl = uri;
           } else {
             throw new Error('不支持的URI格式: ' + uri);
           }
           
           // HTTP GET请求获取代币信息
           let response = await fetch(ipfsUrl);
           
           // 如果是IPFS且第一个网关失败，尝试其他网关
           if (uri.startsWith('ipfs://') && !response.ok) {
             for (let i = 1; i < ipfsGateways.length; i++) {
               try {
                 const backupUrl = uri.replace('ipfs://', ipfsGateways[i]);
                 console.log(`尝试备用IPFS网关: ${backupUrl}`);
                 response = await fetch(backupUrl);
                 if (response.ok) {
                   ipfsUrl = backupUrl;
                   break;
                 }
               } catch (e) {
                 console.log(`网关 ${ipfsGateways[i]} 失败:`, e);
                 continue;
               }
             }
           }
           
           if (!response.ok) {
             throw new Error(`所有IPFS网关都失败，最后尝试: ${response.status}`);
           }
           
           const tokenData = await response.json();
           console.log('获取到代币信息:', tokenData);
           
           // 宽松校验与字段兜底
           const metaName = (tokenData && tokenData.name) ? String(tokenData.name) : '';
           const metaSymbol = (tokenData && tokenData.symbol) ? String(tokenData.symbol) : '';
           
           // 规范化图片URL（处理 ipfs:// 与 /ipfs/ 前缀）
           let resolvedImage = tokenData.image || '';
           try {
             if (resolvedImage) {
               const gatewayBase = (ipfsUrl && ipfsUrl.startsWith('http') && ipfsUrl.includes('/ipfs/'))
                 ? (ipfsUrl.split('/ipfs/')[0] + '/ipfs/')
                 : 'https://ipfs.io/ipfs/';

               if (typeof resolvedImage === 'string') {
                 if (resolvedImage.startsWith('ipfs://ipfs/')) {
                   const cidPart = resolvedImage.replace('ipfs://ipfs/', '');
                   resolvedImage = gatewayBase + cidPart;
                 } else if (resolvedImage.startsWith('ipfs://')) {
                   const cidPart = resolvedImage.replace('ipfs://', '');
                   resolvedImage = gatewayBase + cidPart;
                 } else if (resolvedImage.startsWith('/ipfs/')) {
                   const cidPart = resolvedImage.replace('/ipfs/', '');
                   resolvedImage = gatewayBase + cidPart;
                 }
               }
             }
           } catch (normalizeErr) {
             console.warn('图片URL规范化失败，使用原始image字段:', normalizeErr);
           }

           // 创建代币信息对象
           const tokenInfo = {
             address: address,
             name: metaName,
             symbol: metaSymbol,
             image: resolvedImage,
             twitter: tokenData.twitter || '',
             telegram: tokenData.telegram || '',
             website: tokenData.website || '',
             timestamp: Date.now(),
             source: 'okay-monitoring'
           };
           
           // 如果代币不在deployedTokens中，添加它
           if (!window.tokenData[address]) {
             window.tokenData[address] = tokenInfo;
             window.deployedTokens.push(tokenInfo);
           }
           
           return tokenInfo;
         } catch (error) {
           console.error('获取代币信息失败:', error);
           throw new Error('无法获取代币信息: ' + error.message);
         }
       }
       
       // 测试指定的代币合约
       async function testSpecificToken() {
         const testAddress = '0xfd09526b00afa829c0f855d02eff47cd2a009595';
         console.log('开始测试指定代币:', testAddress);
         
         try {
           // 检查是否已经在监控中
           if (okayMonitoredAddresses.has(testAddress)) {
             alert('该代币已在OKAY监控列表中');
             return;
           }
           
           console.log('正在获取代币信息...');
           // 从Token合约获取代币信息
           const tokenInfo = await getTokenInfoFromContract(testAddress);
           console.log('获取到的代币信息:', tokenInfo);
           
           if (tokenInfo) {
             // 添加到OKAY监控列表
             okayMonitoredAddresses.add(testAddress);
             
             // 保存到本地存储
             saveOkayMonitoredTokens();
             
             // 保存到Firebase
             await saveToFirebase({
               okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // 更新显示
             updateOkayMonitoringDisplay();
             
             // 添加历史记录
             addHistoryRecord('monitor', `测试添加OKAY监控: ${tokenInfo.name || 'Unknown Token'}`, testAddress, {
               description: tokenInfo.name,
               symbol: tokenInfo.symbol,
               image: tokenInfo.image
             });
             
             showNotification(`测试成功！已添加到OKAY监控: ${tokenInfo.name}`, 'success');
             
             // 显示详细信息
             alert(`测试成功！\n\n代币名称: ${tokenInfo.name}\n代币符号: ${tokenInfo.symbol}\n合约地址: ${testAddress}\n\n该代币已成功添加到OKAY监控列表！`);
           }
         } catch (error) {
           console.error('测试指定代币失败:', error);
           alert('测试失败: ' + error.message + '\n\n请检查控制台获取详细错误信息。');
         }
       }
       
       // 获取DYOR发射台代币的实时价格和流动性信息
       async function getDYORTokenPriceAndLiquidity(tokenAddress) {
         try {
           if (!readProvider) {
             throw new Error('只读Provider未初始化');
           }
           
           // 创建Router合约实例
           const routerContract = new ethers.Contract(CONFIG.PUMPU_ROUTER, CONFIG.ROUTER_ABI, readProvider);
           
           // 获取代币对地址（这里假设是WOKB/Token对）
           const wokbAddress = CONFIG.WOKB;
           const tokenAddress = tokenAddress;
           
           // 计算价格：1 OKB能买多少代币
           const amountIn = ethers.utils.parseEther('1'); // 1 OKB
           const path = [wokbAddress, tokenAddress];
           
           try {
             const amounts = await routerContract.getAmountsOut(amountIn, path);
             const tokenAmount = amounts[1];
             const price = parseFloat(ethers.utils.formatUnits(tokenAmount, 18));
             
             // 计算流动性（通过Pair合约获取）
             let liquidity = 0;
             try {
               // 尝试获取流动性池信息 - 代币地址就是池子地址
               const pairContract = new ethers.Contract(tokenAddress, PAIR_ABI, readProvider);
               const [reserve0, reserve1] = await pairContract.getReserves();
               const [token0, token1] = await Promise.all([
                 pairContract.token0(),
                 pairContract.token1()
               ]);
               
               if (token0.toLowerCase() === wokbAddress.toLowerCase()) {
                 // WOKB是token0
                 liquidity = parseFloat(ethers.utils.formatEther(reserve0));
               } else if (token1.toLowerCase() === wokbAddress.toLowerCase()) {
                 // WOKB是token1
                 liquidity = parseFloat(ethers.utils.formatEther(reserve1));
               }
             } catch (liquidityError) {
               console.warn('无法获取流动性信息:', liquidityError);
               // 尝试作为Pumpu代币读取
               try {
                 const pumpContract = new ethers.Contract(tokenAddress, PUMP_TOKEN_EXT_ABI, readProvider);
                 const [vEth, rEth] = await Promise.all([
                   pumpContract.virtualEth().catch(() => ethers.constants.Zero),
                   pumpContract.realEth().catch(() => ethers.constants.Zero)
                 ]);
                 liquidity = parseFloat(ethers.utils.formatEther(vEth.add(rEth)));
               } catch (pumpError) {
                 console.warn('无法获取Pumpu流动性信息:', pumpError);
                 liquidity = 0;
               }
             }
             
             // 获取代币总供应量和精度，计算市值
             let totalSupply = 0;
             let marketCap = 0;
             try {
               const tokenContract = new ethers.Contract(tokenAddress, ERC20_METADATA_ABI, readProvider);
               const [supply, decimals] = await Promise.all([
                 tokenContract.totalSupply(),
                 tokenContract.decimals()
               ]);
               
               totalSupply = parseFloat(ethers.utils.formatUnits(supply, decimals));
               
               // 计算市值：总供应量 × 价格
               if (price > 0 && totalSupply > 0) {
                 marketCap = totalSupply * price;
               }
             } catch (capError) {
               console.warn('无法获取市值信息:', capError);
               totalSupply = 0;
               marketCap = 0;
             }
             
             return {
               price: price,
               liquidity: liquidity,
               totalSupply: totalSupply,
               marketCap: marketCap,
               timestamp: Date.now()
             };
           } catch (priceError) {
             console.warn('无法获取价格信息:', priceError);
             return {
               price: 0,
               liquidity: 0,
               totalSupply: 0,
               marketCap: 0,
               timestamp: Date.now()
             };
           }
         } catch (error) {
           console.error('获取DYOR代币价格和流动性失败:', error);
           return {
             price: 0,
             liquidity: 0,
             totalSupply: 0,
             marketCap: 0,
             timestamp: Date.now()
           };
         }
       }
       
                // 手动刷新单个DYOR代币的价格和流动性
         async function refreshDYORTokenPrice(tokenAddress) {
           try {
             const token = deployedTokens.find(t => t.address === tokenAddress);
             if (!token) {
               throw new Error('代币不存在');
             }
             
             if (okayMonitoredAddresses.has(tokenAddress)) {
               throw new Error('这是OKAY发射台代币，无法刷新DYOR价格');
             }
             
             updateDYORPriceStatus(`🔄 正在刷新 ${token.description || '代币'} 价格...`, 'info');
             console.log(`🔄 正在刷新代币 ${token.description || tokenAddress} 的价格和流动性...`);
             
             const priceData = await getDYORTokenPriceAndLiquidity(tokenAddress);
             
             if (priceData.price > 0) {
               token.price = priceData.price;
               token.liquidity = priceData.liquidity;
               token.totalSupply = priceData.totalSupply;
               token.marketCap = priceData.marketCap;
               token.lastPriceUpdate = priceData.timestamp;
               
               // 计算价格变化百分比
               if (token.lastPrice && token.lastPrice > 0) {
                 const priceChange = ((priceData.price - token.lastPrice) / token.lastPrice) * 100;
                 token.priceChange = priceChange;
               }
               
               token.lastPrice = priceData.price;
               
               // 更新显示
               updateTokenDisplay();
               
               // 更新价格概览
               updateDYORPriceSummary();
               
               const successMessage = `✅ ${token.description || '代币'} 价格已更新: ${priceData.price.toFixed(6)} OKB`;
               updateDYORPriceStatus(successMessage, 'success');
               showNotification(successMessage, 'success');
               
               // 3秒后恢复默认状态
               setTimeout(() => {
                 updateDYORPriceStatus('🔄 监控中...', 'info');
               }, 3000);
             } else {
               const warningMessage = `⚠️ 无法获取 ${token.description || '代币'} 的价格信息`;
               updateDYORPriceStatus(warningMessage, 'warning');
               showNotification(warningMessage, 'warning');
               
               // 3秒后恢复默认状态
               setTimeout(() => {
                 updateDYORPriceStatus('🔄 监控中...', 'info');
               }, 3000);
             }
           } catch (error) {
             console.error('刷新代币价格失败:', error);
             showNotification(`❌ 刷新价格失败: ${error.message}`, 'error');
           }
         }
         
                  // 批量更新DYOR发射台代币的价格和流动性
         async function updateDYORTokensPriceAndLiquidity() {
           try {
             const dyorTokens = deployedTokens.filter(token => 
               !okayMonitoredAddresses.has(token.address) && token.status === 'opened'
             );
             
             if (dyorTokens.length === 0) {
               updateDYORPriceStatus('📊 暂无开盘的DYOR代币', 'info');
               return;
             }
             
             updateDYORPriceStatus(`🔄 正在更新 ${dyorTokens.length} 个代币的价格...`, 'info');
             console.log(`🔄 正在更新 ${dyorTokens.length} 个DYOR发射台代币的价格和流动性...`);
             
             let updatedCount = 0;
             for (const token of dyorTokens) {
               try {
                 const priceData = await getDYORTokenPriceAndLiquidity(token.address);
                 
                 // 更新代币数据
                 if (priceData.price > 0) {
                   token.price = priceData.price;
                   token.liquidity = priceData.liquidity;
                   token.totalSupply = priceData.totalSupply;
                   token.marketCap = priceData.marketCap;
                   token.lastPriceUpdate = priceData.timestamp;
                   
                   // 计算价格变化百分比
                   if (token.lastPrice && token.lastPrice > 0) {
                     const priceChange = ((priceData.price - token.lastPrice) / token.lastPrice) * 100;
                     token.priceChange = priceChange;
                     
                     // 检查价格变化警报
                     checkDYORPriceAlerts(token);
                   }
                   
                   token.lastPrice = priceData.price;
                   updatedCount++;
                 }
                 
                 // 添加小延迟避免请求过于频繁
                 await new Promise(resolve => setTimeout(resolve, 100));
               } catch (error) {
                 console.warn(`更新代币 ${token.address} 价格失败:`, error);
               }
             }
             
             // 更新显示
             updateTokenDisplay();
             
             // 更新价格概览
             updateDYORPriceSummary();
             
             // 保存更新后的数据到Firebase
             try {
               await saveToFirebase({
                 tokens: deployedTokens,
                 tokenData: tokenData,
                 lastUpdated: Date.now()
               }, 'pumpu_tokens');
               console.log('✅ 价格数据已保存到Firebase');
             } catch (firebaseError) {
               console.warn('保存价格数据到Firebase失败:', firebaseError);
             }
             
             const statusMessage = `✅ 已更新 ${updatedCount}/${dyorTokens.length} 个代币价格`;
             updateDYORPriceStatus(statusMessage, 'success');
             console.log('✅ DYOR发射台代币价格和流动性更新完成');
             
             // 3秒后恢复默认状态
             setTimeout(() => {
               updateDYORPriceStatus('🔄 监控中...', 'info');
             }, 3000);
           } catch (error) {
             console.error('批量更新DYOR代币价格失败:', error);
             updateDYORPriceStatus('❌ 更新失败', 'error');
           }
         }
       
       // 从OKAY监控中移除代币
       async function removeFromOkayMonitoring(address) {
         if (confirm('确定要从OKAY监控中移除该代币吗？')) {
           try {
             okayMonitoredAddresses.delete(address);
             
             // 保存到本地存储
             saveOkayMonitoredTokens();
             
             // 保存到Firebase
             await saveToFirebase({
               okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // 更新显示
             updateOkayMonitoringDisplay();
             
             // 添加历史记录
             const token = tokenData[address];
             addHistoryRecord('monitor', `从OKAY监控移除: ${token?.name || token?.description || 'Unknown Token'}`, address, {
               description: token?.name || token?.description
             });
             
             showNotification('已从OKAY监控中移除', 'success');
           } catch (error) {
             console.error('移除OKAY监控代币失败:', error);
             alert('移除失败: ' + error.message);
           }
         }
       }
       
       // 清空所有OKAY监控代币
       async function clearAllOkayTokens() {
         if (confirm('确定要清空所有OKAY监控代币吗？此操作不可恢复。')) {
           try {
             okayMonitoredAddresses.clear();
             
             // 保存到本地存储
             saveOkayMonitoredTokens();
             
             // 保存到Firebase
             await saveToFirebase({
               okayMonitoredAddresses: [],
               lastUpdated: Date.now()
             }, 'pumpu_okay_tokens');
             
             // 更新显示
             updateOkayMonitoringDisplay();
             
             // 添加历史记录
             addHistoryRecord('monitor', '清空所有OKAY监控代币', null, {});
             
             showNotification('已清空所有OKAY监控代币', 'success');
           } catch (error) {
             console.error('清空OKAY监控代币失败:', error);
             alert('清空失败: ' + error.message);
           }
         }
       }
       
       // 创建发射台统计信息
       function createLaunchpadStats(launchpadType, tokens) {
         const totalTokens = tokens.length;
         const openedTokens = tokens.filter(t => t.status === 'opened').length;
         const pendingTokens = tokens.filter(t => t.status === 'pending').length;
         const newTokens = tokens.filter(t => t.status === 'new').length;
         
         const statsClass = launchpadType === 'okay' ? 'okay' : '';
         const title = launchpadType === 'okay' ? 'OKAY发射台统计' : 'DYOR发射台统计';
         
         // 为DYOR发射台添加价格、流动性和市值统计
         let additionalStats = '';
         if (launchpadType !== 'okay') {
           const tokensWithPrice = tokens.filter(t => t.status === 'opened' && t.price && t.price > 0);
           const avgPrice = tokensWithPrice.length > 0 ? 
             (tokensWithPrice.reduce((sum, t) => sum + t.price, 0) / tokensWithPrice.length).toFixed(6) : '0';
           const totalLiquidity = tokensWithPrice.reduce((sum, t) => sum + (t.liquidity || 0), 0).toFixed(2);
           const totalMarketCap = tokensWithPrice.reduce((sum, t) => sum + (t.marketCap || 0), 0);
           
           additionalStats = `
             <div class="stat-item">
               <div class="stat-value">${avgPrice}</div>
               <div class="stat-label">平均价格(OKB)</div>
             </div>
             <div class="stat-item">
               <div class="stat-value">${totalLiquidity}</div>
               <div class="stat-label">总池子OKB</div>
             </div>
             <div class="stat-item">
               <div class="stat-value">${formatMarketCap(totalMarketCap)}</div>
               <div class="stat-label">总市值</div>
             </div>
           `;
         }
         
         return `
           <div class="launchpad-stats ${statsClass}">
             <h3>📊 ${title}</h3>
             <div class="stats-grid">
               <div class="stat-item">
                 <div class="stat-value">${totalTokens}</div>
                 <div class="stat-label">总代币数</div>
               </div>
               <div class="stat-item">
                 <div class="stat-value">${openedTokens}</div>
                 <div class="stat-label">已开盘</div>
               </div>
               <div class="stat-item">
                 <div class="stat-value">${pendingTokens}</div>
                 <div class="stat-label">即将打满</div>
               </div>
               <div class="stat-item">
                 <div class="stat-value">${newTokens}</div>
                 <div class="stat-label">新创建</div>
               </div>
               ${additionalStats}
             </div>
           </div>
         `;
       }
       
       
       
       // 增强的通知系统
           function showNotification(message, type = 'info', duration = 3000) {
           if (!userPreferences.notificationEnabled) return;
           
           const notification = document.createElement('div');
           notification.className = `notification ${type}`;
           notification.textContent = message;
           
           document.body.appendChild(notification);
           
           // 播放声音提醒
           if (userPreferences.soundEnabled && type === 'success') {
             playNotificationSound();
           }
           
           setTimeout(() => {
             if (notification.parentElement) {
               notification.remove();
             }
           }, duration);
         }
         
         // 声音提醒
         function playNotificationSound() {
           try {
             // 创建音频上下文播放提示音
             const audioContext = new (window.AudioContext || window.webkitAudioContext)();
             const oscillator = audioContext.createOscillator();
             const gainNode = audioContext.createGain();
             
             oscillator.connect(gainNode);
             gainNode.connect(audioContext.destination);
             
             oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
             oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
             oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
             
             gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
             gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
             
             oscillator.start(audioContext.currentTime);
             oscillator.stop(audioContext.currentTime + 0.3);
           } catch (error) {
             console.error('播放声音失败:', error);
           }
         }
         
         // 价格监控系统
         function startPriceMonitoring() {
           console.log('🚀 启动价格监控系统...');
           
           // 每5秒检查一次价格变化
           setInterval(() => {
             deployedTokens.forEach(token => {
               if (token.isMonitored && token.status === 'opened') {
                 checkPriceChange(token);
               }
             });
           }, 5000);
           
           // 每30秒更新DYOR发射台代币的价格和流动性
           setInterval(async () => {
             await updateDYORTokensPriceAndLiquidity();
           }, 30000);
           
           // 立即执行一次价格更新
           setTimeout(async () => {
             await updateDYORTokensPriceAndLiquidity();
           }, 2000);
           
           // 初始化价格概览
           setTimeout(() => {
             updateDYORPriceSummary();
           }, 1000);
           
           showNotification('✅ DYOR发射台代币价格监控已启动', 'success');
         }
         
         function checkPriceChange(token) {
           const currentPrice = token.price || 0;
           const lastPrice = token.lastPrice || currentPrice;
           
           if (lastPrice > 0 && currentPrice > 0) {
             const changePercent = Math.abs(currentPrice - lastPrice) / lastPrice;
             
             if (changePercent >= userPreferences.priceChangeThreshold) {
               const direction = currentPrice > lastPrice ? '上涨' : '下跌';
               const changeText = `${(changePercent * 100).toFixed(2)}%`;
               
               showNotification(
                 `${token.description || '代币'} 价格${direction} ${changeText}`,
                 currentPrice > lastPrice ? 'success' : 'warning'
               );
               
               if (userPreferences.soundEnabled) {
                 playNotificationSound();
               }
             }
           }
           
           token.lastPrice = currentPrice;
         }
         
         // 更新DYOR价格监控状态显示
         function updateDYORPriceStatus(message, type = 'info') {
           const statusElement = document.getElementById('dyor-price-status');
           if (statusElement) {
             const colors = {
               'info': '#00ff00',
               'success': '#00ff00',
               'warning': '#ffaa00',
               'error': '#ff4444'
             };
             
             statusElement.style.color = colors[type] || colors.info;
             statusElement.textContent = message;
           }
         }
         
         // 更新DYOR价格概览显示
         function updateDYORPriceSummary() {
           const summaryElement = document.getElementById('dyor-price-summary');
           const detailsElement = document.getElementById('dyor-price-details');
           
           if (!summaryElement || !detailsElement) return;
           
           const dyorTokens = deployedTokens.filter(token => 
             !okayMonitoredAddresses.has(token.address) && token.status === 'opened'
           );
           
           const tokensWithPrice = dyorTokens.filter(t => t.price && t.price > 0);
           
           if (tokensWithPrice.length === 0) {
             summaryElement.textContent = '暂无价格数据';
             detailsElement.innerHTML = '等待代币开盘或价格更新...';
             return;
           }
           
           // 计算价格统计
           const prices = tokensWithPrice.map(t => t.price);
           const minPrice = Math.min(...prices);
           const maxPrice = Math.max(...prices);
           const avgPrice = prices.reduce((sum, p) => sum + p, 0) / prices.length;
           
           const totalLiquidity = tokensWithPrice.reduce((sum, t) => sum + (t.liquidity || 0), 0);
           const totalMarketCap = tokensWithPrice.reduce((sum, t) => sum + (t.marketCap || 0), 0);
           
           // 计算价格变化统计
           const tokensWithChange = tokensWithPrice.filter(t => t.priceChange !== undefined);
           const positiveChanges = tokensWithChange.filter(t => t.priceChange > 0);
           const negativeChanges = tokensWithChange.filter(t => t.priceChange < 0);
           
           summaryElement.textContent = `${tokensWithPrice.length}个代币 | 平均价格: ${avgPrice.toFixed(6)} OKB | 总市值: ${formatMarketCap(totalMarketCap)}`;
           
           detailsElement.innerHTML = `
             <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 5px;">
               <div>最低价格: <span style="color: #00ff00;">${minPrice.toFixed(6)} OKB</span></div>
               <div>最高价格: <span style="color: #ff4444;">${maxPrice.toFixed(6)} OKB</span></div>
               <div>总池子OKB: <span style="color: #00d8ff;">${totalLiquidity.toFixed(2)} OKB</span></div>
               <div>总市值: <span style="color: #ff00ff;">${formatMarketCap(totalMarketCap)}</span></div>
               <div>上涨代币: <span style="color: #00ff00;">${positiveChanges.length}个</span></div>
               <div>下跌代币: <span style="color: #ff4444;">${negativeChanges.length}个</span></div>
               <div>稳定代币: <span style="color: #aaa;">${tokensWithChange.length - positiveChanges.length - negativeChanges.length}个</span></div>
             </div>
           `;
         }
         
         // 检查DYOR代币价格变化并显示警报
         function checkDYORPriceAlerts(token) {
           if (!token.price || !token.lastPrice || token.lastPrice <= 0) return;
           
           const changePercent = Math.abs(token.price - token.lastPrice) / token.lastPrice;
           
           if (changePercent >= userPreferences.priceChangeThreshold) {
             const direction = token.price > token.lastPrice ? '📈 上涨' : '📉 下跌';
             const changeText = `${(changePercent * 100).toFixed(2)}%`;
             const currentPrice = token.price.toFixed(6);
             
             showNotification(
               `🚀 DYOR发射台: ${token.description || '代币'} ${direction} ${changeText}<br/>当前价格: ${currentPrice} OKB`,
               token.price > token.lastPrice ? 'success' : 'warning',
               5000
             );
             
             if (userPreferences.soundEnabled) {
               playNotificationSound();
             }
           }
         }
         
         // 设置面板
         function showSettings() {
           const panel = document.createElement('div');
           panel.className = 'settings-panel';
           panel.innerHTML = `
             <h3>⚙️ 设置</h3>
             <div class="setting-item">
               <label>启用声音提醒</label>
               <input type="checkbox" id="soundEnabled" ${userPreferences.soundEnabled ? 'checked' : ''}>
             </div>
             <div class="setting-item">
               <label>启用弹窗通知</label>
               <input type="checkbox" id="notificationEnabled" ${userPreferences.notificationEnabled ? 'checked' : ''}>
             </div>
             <div class="setting-item">
               <label>自动刷新</label>
               <input type="checkbox" id="autoRefresh" ${userPreferences.autoRefresh ? 'checked' : ''}>
             </div>
             <div class="setting-item">
               <label>价格变化阈值 (%)</label>
               <input type="number" id="priceThreshold" value="${userPreferences.priceChangeThreshold * 100}" min="1" max="100">
             </div>
             <div class="setting-item">
               <label>最小流动性阈值 (OKB)</label>
               <input type="number" id="liquidityThreshold" value="${userPreferences.minLiquidityThreshold}" min="10" max="1000">
             </div>
             <div style="text-align: center; margin-top: 20px;">
               <button class="buy-btn" onclick="saveSettings()">保存设置</button>
               <button class="refresh-btn" onclick="closeSettings()" style="margin-left: 10px;">取消</button>
             </div>
           `;
           
           document.body.appendChild(panel);
           panel.style.display = 'block';
           
           // 绑定事件
           document.getElementById('soundEnabled').addEventListener('change', (e) => {
             userPreferences.soundEnabled = e.target.checked;
           });
           
           document.getElementById('notificationEnabled').addEventListener('change', (e) => {
             userPreferences.notificationEnabled = e.target.checked;
           });
           
           document.getElementById('autoRefresh').addEventListener('change', (e) => {
             userPreferences.autoRefresh = e.target.checked;
           });
           
           document.getElementById('priceThreshold').addEventListener('change', (e) => {
             userPreferences.priceChangeThreshold = parseFloat(e.target.value) / 100;
           });
           
           document.getElementById('liquidityThreshold').addEventListener('change', (e) => {
             userPreferences.minLiquidityThreshold = parseFloat(e.target.value);
           });
         }
         
         function saveSettings() {
           saveUserPreferences();
           showNotification('设置已保存', 'success');
           closeSettings();
         }
         
         function closeSettings() {
           const panel = document.querySelector('.settings-panel');
           if (panel) {
             panel.remove();
           }
         }
         
         // 强制刷新所有代币的名称和符号
         async function forceRefreshTokenNames() {
           try {
             showNotification('🔄 正在强制刷新代币名称...', 'info');
             
             const targets = deployedTokens.filter(t => t && t.address);
             let updated = 0;
             
             for (const token of targets) {
               try {
                 // 强制从合约重新读取名称和符号
                 const erc20Contract = new ethers.Contract(token.address, ERC20_METADATA_ABI, readProvider);
                 const [name, symbol] = await Promise.all([
                   erc20Contract.name().catch(() => ''),
                   erc20Contract.symbol().catch(() => '')
                 ]);
                 
                 let changed = false;
                 if (name && typeof name === 'string' && name.trim() && name !== token.name) {
                   token.name = name.trim();
                   changed = true;
                 }
                 if (symbol && typeof symbol === 'string' && symbol.trim() && symbol !== token.symbol) {
                   token.symbol = symbol.trim();
                   changed = true;
                 }
                 
                 if (changed) {
                   updated++;
                   console.log(`✅ 更新代币 ${token.address}: name="${token.name}", symbol="${token.symbol}"`);
                   
                   // 同步更新 tokenData 中的对应数据
                   if (tokenData[token.address]) {
                     tokenData[token.address].name = token.name;
                     tokenData[token.address].symbol = token.symbol;
                   }
                 }
                 
                 // 添加小延迟避免请求过快
                 await new Promise(resolve => setTimeout(resolve, 100));
               } catch (e) {
                 console.warn(`刷新代币 ${token.address} 名称失败:`, e);
               }
             }
             
             // 同步数据源
             syncTokenNames();
             
             // 更新显示
             updateTokenDisplay();
             
             // 保存到 Firebase
             try {
               await saveToFirebase({
                 tokens: deployedTokens,
                 tokenData: tokenData,
                 lastUpdated: Date.now()
               }, 'pumpu_tokens');
               console.log('✅ 名称更新已保存到 Firebase');
             } catch (e) {
               console.warn('保存名称更新到 Firebase 失败:', e);
             }
             
             showNotification(`✅ 名称刷新完成：${updated}/${targets.length} 个代币已更新`, 'success');
           } catch (error) {
             console.error('强制刷新代币名称失败:', error);
             showNotification('❌ 名称刷新失败：' + error.message, 'error');
           }
         }
         
         // 获取池子详细信息（OKB数量、代币数量、价格等）
         async function getPoolDetails(tokenAddress) {
           try {
             if (!readProvider) {
               throw new Error('只读Provider未初始化');
             }
             
             // 尝试作为 UniswapV2 Pair 读取
             try {
               const pair = new ethers.Contract(tokenAddress, PAIR_ABI, readProvider);
               const [reserve0, reserve1] = await pair.getReserves();
               const [token0, token1] = await Promise.all([
                 pair.token0(),
                 pair.token1()
               ]);
               
               const wokbLower = CONFIG.WOKB.toLowerCase();
               let okbReserve = 0;
               let tokenReserve = 0;
               let price = 0;
               
               if (token0.toLowerCase() === wokbLower) {
                 okbReserve = Number(ethers.utils.formatEther(reserve0));
                 tokenReserve = Number(ethers.utils.formatEther(reserve1));
               } else if (token1.toLowerCase() === wokbLower) {
                 okbReserve = Number(ethers.utils.formatEther(reserve1));
                 tokenReserve = Number(ethers.utils.formatEther(reserve0));
               }
               
               if (tokenReserve > 0) {
                 price = okbReserve / tokenReserve;
               }
               
               return {
                 okbAmount: okbReserve,
                 tokenAmount: tokenReserve,
                 price: price,
                 type: 'uniswap_v2_pair'
               };
             } catch (e) {
                                // 尝试作为 Pumpu 代币读取
                 try {
                   const pump = new ethers.Contract(tokenAddress, PUMP_TOKEN_EXT_ABI, readProvider);
                   const [vEth, vTok] = await Promise.all([
                     pump.virtualEth().catch(() => ethers.constants.Zero),
                     pump.virtualToken().catch(() => ethers.constants.Zero)
                   ]);
                   
                   const okbReserve = Number(ethers.utils.formatEther(vEth));
                   const tokenReserve = Number(ethers.utils.formatEther(vTok));
                   let price = 0;
                   
                   if (tokenReserve > 0) {
                     price = okbReserve / tokenReserve;
                   }
                   
                   return {
                     okbAmount: okbReserve,
                     tokenAmount: tokenReserve,
                     price: price,
                     type: 'pumpu_token'
                   };
                 } catch (e2) {
                   throw new Error('无法识别池子类型');
                 }
             }
           } catch (error) {
             console.error('获取池子详情失败:', error);
             return {
               okbAmount: 0,
               tokenAmount: 0,
               price: 0,
               type: 'unknown'
             };
           }
         }
         

         
         // 同步 deployedTokens 和 tokenData 中的名称数据
         function syncTokenNames() {
           try {
             deployedTokens.forEach(token => {
               if (tokenData[token.address]) {
                 // 如果 deployedTokens 中有名称但 tokenData 中没有，同步过去
                 if (token.name && !tokenData[token.address].name) {
                   tokenData[token.address].name = token.name;
                 }
                 if (token.symbol && !tokenData[token.address].symbol) {
                   tokenData[token.address].symbol = token.symbol;
                 }
                 
                 // 如果 tokenData 中有名称但 deployedTokens 中没有，同步过来
                 if (tokenData[token.address].name && !token.name) {
                   token.name = tokenData[token.address].name;
                 }
                 if (tokenData[token.address].symbol && !token.symbol) {
                   token.symbol = tokenData[token.address].symbol;
                 }
               }
             });
             
             console.log('✅ 代币名称数据同步完成');
           } catch (error) {
             console.error('代币名称数据同步失败:', error);
           }
         }
         
         // 格式化市值显示
         function formatMarketCap(marketCap) {
           if (marketCap >= 1000000) {
             return (marketCap / 1000000).toFixed(2) + 'M OKB';
           } else if (marketCap >= 1000) {
             return (marketCap / 1000).toFixed(2) + 'K OKB';
           } else {
             return marketCap.toFixed(2) + ' OKB';
           }
         }
         

         
         // 显示池子详细信息
         async function showPoolDetails(tokenAddress) {
           try {
             showNotification('🔄 正在获取池子详情...', 'info');
             
             const poolInfo = await getPoolDetails(tokenAddress);
             const token = deployedTokens.find(t => t.address === tokenAddress) || tokenData[tokenAddress];
             
             if (!poolInfo || poolInfo.okbAmount === 0) {
               showNotification('❌ 无法获取池子信息', 'error');
               return;
             }
             
             // 创建池子详情弹窗
             const modal = document.createElement('div');
             modal.style.cssText = `
               position: fixed;
               top: 0;
               left: 0;
               width: 100%;
               height: 100%;
               background: rgba(0, 0, 0, 0.8);
               z-index: 10003;
               display: flex;
               align-items: center;
               justify-content: center;
               animation: fadeIn 0.3s ease;
             `;
             
             modal.innerHTML = `
               <div style="background: #1e1e1e; padding: 30px; border-radius: 12px; border: 1px solid #2c2c2c; max-width: 500px; width: 90%;">
                 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                   <h3 style="color: #00d8ff; margin: 0;">🏊 池子详情</h3>
                   <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background: none; border: none; color: #aaa; font-size: 24px; cursor: pointer;">&times;</button>
                 </div>
                 
                 <div style="background: #2c2c2c; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                   <h4 style="color: #00ff00; margin-bottom: 15px;">${token?.name || token?.symbol || '代币'} 池子信息</h4>
                   
                   <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                     <div style="text-align: center; padding: 15px; background: #1e1e1e; border-radius: 6px;">
                       <div style="font-size: 24px; font-weight: bold; color: #00ff00;">${poolInfo.okbAmount.toFixed(2)}</div>
                       <div style="font-size: 12px; color: #aaa;">池子OKB数量</div>
                     </div>
                     
                     <div style="text-align: center; padding: 15px; background: #1e1e1e; border-radius: 6px;">
                       <div style="font-size: 24px; font-weight: bold; color: #00d8ff;">${poolInfo.tokenAmount.toLocaleString()}</div>
                       <div style="font-size: 12px; color: #aaa;">池子代币数量</div>
                     </div>
                   </div>
                   
                   <div style="margin-top: 15px; padding: 15px; background: #1e1e1e; border-radius: 6px; text-align: center;">
                     <div style="font-size: 18px; font-weight: bold; color: #ff00ff;">${poolInfo.price.toFixed(8)} OKB</div>
                     <div style="font-size: 12px; color: #aaa;">当前价格</div>
                   </div>
                   
                   <div style="margin-top: 10px; text-align: center;">
                     <span style="background: #333; color: #00d8ff; padding: 4px 8px; border-radius: 4px; font-size: 11px;">
                       池子类型: ${poolInfo.type === 'uniswap_v2_pair' ? 'Uniswap V2' : poolInfo.type === 'pumpu_token' ? 'Pumpu' : '未知'}
                     </span>

                   </div>
                 </div>
                 
                 <div style="text-align: center;">
                   <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background: #00d8ff; color: #000; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">关闭</button>
                 </div>
               </div>
             `;
             
             document.body.appendChild(modal);
             showNotification('✅ 池子详情已显示', 'success');
             
           } catch (error) {
             console.error('显示池子详情失败:', error);
             showNotification('❌ 显示池子详情失败: ' + error.message, 'error');
           }
         }
         
         // 增强的开盘通知
         function showOpeningNotification(token) {
           showNotification(`🚀 ${token.description || '代币'} 已开盘！`, 'success', 8000);
           
           // 创建更醒目的弹窗
           const modal = document.createElement('div');
           modal.style.cssText = `
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background: rgba(0, 255, 0, 0.9);
             z-index: 10002;
             display: flex;
             align-items: center;
             justify-content: center;
             animation: fadeIn 0.5s ease;
           `;
           
           modal.innerHTML = `
             <div style="background: #000; padding: 40px; border-radius: 20px; text-align: center; max-width: 500px;">
               <h1 style="color: #00ff00; font-size: 48px; margin-bottom: 20px;">🚀</h1>
               <h2 style="color: #fff; margin-bottom: 20px;">代币已开盘！</h2>
               <p style="color: #00ff00; font-size: 18px; margin-bottom: 20px;"><strong>${token.description || 'Unknown Token'}</strong></p>
               <p style="color: #ccc; margin-bottom: 30px;">地址: ${token.address.substring(0, 8)}...${token.address.substring(36)}</p>
               <button onclick="this.parentElement.parentElement.remove()" style="background: #00ff00; color: #000; padding: 15px 30px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer;">知道了</button>
             </div>
           `;
           
           document.body.appendChild(modal);
           
           // 10秒后自动关闭
           setTimeout(() => {
             if (modal.parentElement) {
               modal.remove();
             }
           }, 10000);
         }
         
         // 更新同步状态显示
         function updateSyncStatus(status, message) {
           const indicator = document.getElementById('sync-indicator');
           if (indicator) {
             indicator.textContent = `${status} ${message}`;
           }
         }

                   // 定期保存数据到 Firebase
          setInterval(async () => {
            try {
              updateSyncStatus('🔄', '同步中...');
              await saveToFirebase({
                tokens: deployedTokens,
                tokenData: tokenData,
                monitoredAddresses: Array.from(monitoredAddresses),
                lastUpdated: Date.now()
              }, 'pumpu_tokens');
              
              // 保存OKAY监控代币数据
              await saveToFirebase({
                okayMonitoredAddresses: Array.from(okayMonitoredAddresses),
                lastUpdated: Date.now()
              }, 'pumpu_okay_tokens');
              
              console.log('🔄 定期保存到 Firebase 完成');
              updateSyncStatus('✅', '已同步');
              
              // 3秒后恢复默认状态
              setTimeout(() => {
                updateSyncStatus('🔄', '同步中...');
              }, 3000);
            } catch (error) {
              console.error('定期保存到 Firebase 失败:', error);
              updateSyncStatus('❌', '同步失败');
            }
          }, 30000); // 每30秒保存一次
         
         // 添加设置按钮到顶部导航
         document.addEventListener('DOMContentLoaded', () => {
           const topNav = document.querySelector('.top-nav');
           if (topNav) {
             const settingsBtn = document.createElement('button');
             settingsBtn.className = 'refresh-btn';
             settingsBtn.style.marginLeft = '10px';
             settingsBtn.textContent = '⚙️ 设置';
             settingsBtn.onclick = showSettings;
             
             const searchDiv = topNav.querySelector('.search');
             if (searchDiv) {
               searchDiv.appendChild(settingsBtn);
             }
           }
         });

    // 解析 DYOR 代币头像（优先 DexScreener，其次 TrustWallet 资产库）
    async function resolveDYORTokenImage(tokenAddress) {
      try {
        const checksum = ethers.utils.getAddress(tokenAddress);
        // 1) DexScreener
        try {
          const dsResp = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${checksum}`);
          if (dsResp.ok) {
            const dsJson = await dsResp.json();
            if (dsJson && Array.isArray(dsJson.pairs) && dsJson.pairs.length > 0) {
              const pair0 = dsJson.pairs[0];
              const img = pair0 && pair0.info && pair0.info.imageUrl ? pair0.info.imageUrl : '';
              if (img) return img;
            }
          }
        } catch (e) { console.warn('DexScreener 查询失败:', e); }
        // 2) TrustWallet
        try {
          const trustUrl = `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/xlayer/assets/${checksum}/logo.png`;
          const head = await fetch(trustUrl, { method: 'HEAD' });
          if (head.ok) return trustUrl;
        } catch (e2) { console.warn('TrustWallet 头像不存在:', e2); }
        return '';
      } catch (err) { console.warn('解析 DYOR 头像失败:', err); return ''; }
    }

    // 从 DexScreener 解析 DYOR 基本信息（name/symbol/image）
    async function resolveDYORTokenMeta(tokenAddress) {
      try {
        const checksum = ethers.utils.getAddress(tokenAddress);
        // 1) 优先从 ERC20 合约直接读取 name/symbol（最快且最可靠）
        try {
          const erc20 = new ethers.Contract(checksum, ERC20_METADATA_ABI, readProvider);
          const [erc20Name, erc20Symbol] = await Promise.all([
            erc20.name().catch(() => ''),
            erc20.symbol().catch(() => '')
          ]);
          if ((erc20Name && typeof erc20Name === 'string') || (erc20Symbol && typeof erc20Symbol === 'string')) {
            return { name: erc20Name || '', symbol: erc20Symbol || '', imageUrl: '' };
          }
        } catch (e0) { /* 忽略，继续使用 DexScreener 兜底 */ }

        // 2) DexScreener 兜底
        try {
          const dsResp = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${checksum}`);
          if (!dsResp.ok) return { name: '', symbol: '', imageUrl: '' };
          const dsJson = await dsResp.json();
          if (!dsJson || !Array.isArray(dsJson.pairs) || dsJson.pairs.length === 0) {
            return { name: '', symbol: '', imageUrl: '' };
          }
          const pair0 = dsJson.pairs[0] || {};
          const base = pair0.baseToken || {};
          const info = pair0.info || {};
          return {
            name: base.name || '',
            symbol: base.symbol || '',
            imageUrl: info.imageUrl || ''
          };
        } catch (e1) {
          return { name: '', symbol: '', imageUrl: '' };
        }
      } catch (e) {
        console.warn('解析 DYOR 基本信息失败:', e);
        return { name: '', symbol: '', imageUrl: '' };
      }
    }

    // 渲染期确保 DYOR 头像与名称/符号
    async function ensureDYORMeta(address) {
      try {
        const t = tokenData[address];
        if (!t || t.source === 'okay-monitoring') return;
        const needName = !t.name;
        const needSymbol = !t.symbol;
        const needImage = !t.image;
        if (!needName && !needSymbol && !needImage) return;

        // 先用 ERC20 读取一次（更可靠）
        let foundName = '';
        let foundSymbol = '';
        try {
          const erc20 = new ethers.Contract(address, ERC20_METADATA_ABI, readProvider);
          const [erc20Name, erc20Symbol] = await Promise.all([
            needName ? erc20.name().catch(() => '') : Promise.resolve(''),
            needSymbol ? erc20.symbol().catch(() => '') : Promise.resolve('')
          ]);
          foundName = (erc20Name && typeof erc20Name === 'string') ? erc20Name : '';
          foundSymbol = (erc20Symbol && typeof erc20Symbol === 'string') ? erc20Symbol : '';
        } catch (_) { /* 忽略 */ }

        // 再用 DexScreener 兜底
        const meta = await resolveDYORTokenMeta(address);

        let changed = false;
        if (needName && (foundName || meta.name)) { tokenData[address].name = foundName || meta.name; changed = true; }
        if (needSymbol && (foundSymbol || meta.symbol)) { tokenData[address].symbol = foundSymbol || meta.symbol; changed = true; }
        if (needImage && meta.imageUrl) { tokenData[address].image = meta.imageUrl; changed = true; }
        if (changed) updateTokenDisplay();
      } catch (e) { console.warn('ensureDYORMeta 失败:', e); }
    }

    // 从描述中提取可能的 name/symbol 兜底
    function extractNameSymbolFromDescription(desc) {
      try {
        if (!desc || typeof desc !== 'string') return { name: '', symbol: '' };
        
        // 如果描述是纯URL，不提取名称
        if (desc.match(/^https?:\/\/\S+$/)) {
          return { name: '', symbol: '' };
        }
        
        let text = desc.replace(/https?:\/\/\S+/g, ' ').replace(/[\u{1F300}-\u{1FAFF}\u{1F600}-\u{1F64F}]/gu, ' ').trim();
        text = text.replace(/[^A-Za-z0-9 _\-]/g, ' ').replace(/\s+/g, ' ').trim();
        
        if (!text || text.length < 2) return { name: '', symbol: '' };
        
        // 常见格式: NAME SYMBOL, NAME - SYMBOL, NAME(SYMBOL)
        const paren = text.match(/^([^()]{2,})\(([^()]{1,12})\)/);
        if (paren) return { name: paren[1].trim().slice(0, 24), symbol: paren[2].trim().slice(0, 12) };
        
        const dash = text.match(/^(.{2,})\s[-|–|—]\s([A-Za-z0-9]{1,12})/);
        if (dash) return { name: dash[1].trim().slice(0, 24), symbol: dash[2].trim().slice(0, 12) };
        
        const parts = text.split(' ');
        const symbolGuess = (parts.find(p => /^[A-Z0-9]{2,12}$/.test(p)) || '').slice(0, 12);
        const nameGuess = text.slice(0, 24).trim();
        
        // 如果提取的名称太短或看起来不像真实名称，返回空
        if (nameGuess.length < 2 || /^[0-9\s]+$/.test(nameGuess)) {
          return { name: '', symbol: '' };
        }
        
        return { name: nameGuess, symbol: symbolGuess };
      } catch { return { name: '', symbol: '' }; }
    }
   </script>
 
 </body>
</html>
